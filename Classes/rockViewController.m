/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMr7i:                     :i7rMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMX;,                                       ,;XMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM7,                                                   ,7MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMi                                                             iMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM;                                                                     ;MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  aMMMMMMMMMMMMMX:                                                                           :XMMMMMMMMMMMMM  ,MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    MMMMMMMMMMM7,                                                                                 ,7MMMMMMMMMMM   .MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.    MMMMMMMMMM:                                                                                       :MMMMMMMMM7 .  ,MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM   , ,MMMMMMM;                                                                                             ;MMMMMMM  ,   MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  .:  MMMM;,    .:,.                                                                                   ,,:.    ,rMMMX .,.  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  .,. iMM:   ..:::                                     ;,          :rXr.                                 ..:::..   iMM. .,.  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMM; .,. .M7  ..:,i..                               BZ     MZ         aM  X:  ,ZX7r                             .,i,:..  SM  .:  rMMi MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMi  MMM. :,.,Mi .:,i,,                            0X   ;aaa    Za         7M:     ;M :;     :                          :,i,:  rM .,: :MM;  ;MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    MMM .,.;0: .:..                        iZ87   2M   Sr Ma   X8           aMS   MM:      XMa                            ..:. :Z:,,  MMM    MMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMM  , ;MMM  ,;7                              Z8,.     M   0S;,M2  rM        .    MX  M..,   .a,.M    .X                             ri: .MMM. ,  MMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMM  ,. ;MMM :r.                          2r  rM        Za ,8    MZ iMX2Zr    i0X77Z  XM     ;08:XM    M8                              ,;, MMMi .,  MMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMM  ,.. MMM7            ..:,:         r7  SM  7M        ;M ;Z     i             ,,.   7XXSZ.2Z   rM   XM                  :,:..            XMMX ,., .MMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMM7 ,.:  MMM,       ::i:i:;::        XWi.   ZM  MM,  .Z;  r                                  7    ,M  ,M                    :i;:i:i,:       :MMM  :,. MMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMM, .:. SMX    ..i:i:i:i:i.       :  rM. r   M7  7Z8aa;                                           .Z .Mr           ;i:        .i:i:i:i:i.     SMr .:. iMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMi .MM: :, :M;    .:i:i::,:..       iX2   :MZ     Mr                                                     ,2XX;.     .80XXXZ:        ..:,::i:i,.    rM..,, iMM  rMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMM:  XMM: ...M,                      :M2  .  iM     ii                                                        iX      MS     0;                       i0 ,. ;MM:  ;MMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMi   iMMX .,Z.           ..            MZX:   7M:                     ,i7rX8MMMMMMMMMMMMWXXrr,,                      ;M      ;M           .            :a.. MMM.   rMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMM  , iMMM :a         ,,ii,       ;;;    MZ     :                 ;rXMMMMMMMMMMMM@MWMMMMMMMMMMMMM0X;:                  M.     M7   .:       :ii,,         a  MMM, ,  MMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMM  ,, .MMM :      .::i:;:.      XZXX2MX   aM,                ,;XMMMMMMWMW@WMMMi;MMW@WWBWB@W@W@WMMMMMMM27,              ,aSi;XMX   iM8S       .:;:i,:         MMM  .: ,MMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMM ..: .MMM      ::i:i:i.       2S     MS   7,             :rMMMMM@MW@W@W@WMM, .  iMW@BWBWB@W@W@W@W@WMMMMMMXi.            :7rr    ZM  72        .i:i:i,,      MMM  :,. MMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMi .:. iMM:   .:;:i:i,,         M       M               :rMMMMM;rMMM@W@B@WMM: ;MM: iMW@W@W@W@W@W@B@B@W@W@WMMMMSi.               XMr;X             ,,i:i:;,.   iMM. ,:. SMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMM; ,,, WM:   .,:., .            MS     X2            .;MMMMMM;    .MMWW@W@M; iMMMM:.MMW@W@W@W@W@W@BWB@B@W@W@WMMMMX,            SM                    . ,.:,.   iMX :,, 8MMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMM  : .M;                        MMr;;ZS           .XMMMMW@MM .MMi. rM@W@MM .MMW@M; XM@B@W@W@W@W@BMM@W@W@W@W@W@WMMMM;                               .           7M .:  MMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMM  MMM  , 2X         ,::              :SXX.          :XMMMW@WWWMW :MMMM, ZM@MM  MMWWWMi ;MW@W@W@W@W@W@BWB@W@W@W@W@W@W@@MMMi                              ::,         2X .  MMM  MMMMMMMMMMMM
 MMMMMMMMMMMM   MMM7  ;a       ,,ii:                            .XMM@@W@B@B@Mr ;M@WMM .MMM. MMB@B@M: MM@W@W@W@W@W@W@W@W@W@W@W@W@W@W@W@MMM;                             iii,,       Z:  MMMM  ,MMMMMMMMMMM
 MMMMMMMMMMM; . rMMM  8     ..i:i::                            rMMMW@W@W@W@WMi ;MWWWMi.ZMi iMW@W@MM .MMW@W@W@W@W@W@W@W@W@W@W@W@W@W@W@W@WMMM,                            ::i:i..    .Z ,MMM: . 8MMMMMMMMMM
 MMMMMMMMMMM  .  MMM,      ::i:i:,                           iMM@@W@W@B@W@BMM,.MM@B@M7 XM..MM@B@@M: ;MW@W@W@W@W@W@W@W@W@W@W@W@W@W@W@W@B@WMMM7                            ::i:i:,   .  iMMM  .  MMMMMMMMMM
 MMMMMMMMMMM  :  MMMM     i:i:i.                            XMMW@W@W@W@W@B@MM iM@BWWMZ.77 7M@B@WM; :MW@W@W@W@W@W@W@W@W@W@W@W@W@W@W@W@W@W@W@@MM:                           ..i:i:i     MMMM .:  MMMMMMMMMM
 MMMMMMMMMM; ,,, rMMi   .;::..                            .MMMW@WMMMMMMMW@WM; ;MW@B@MS.S.iMMW@WM0 .MM@W@W@W@B@B@W@W@W@W@W@W@W@B@W@W@W@W@W@W@WMMr                             ..::;.   ;MM; ,., MMMMMMMMMM
 MMMMMMMMMMi .:. iM0    ,                                :MM@W@WMr,.,.iMMM@Mr rM@BWMM,iX.rMW@B@M7 iMMW@W@W@BWBWB@W@W@W@W@W@W@BMB@W@W@W@W@W@W@WMMX                                 .    MM  .:  MMMMMMMMMM
 MMMMMMMMMMM ..: 7M          :.                         ;MM@W@BMB ,7ii  ,MMM: MMBWBMW ;X MM@B@WMr :MW@W@W@WMMMM@W@W@W@W@W@W@WWMWW@W@W@W@W@W@W@W@MM                          .:         .Mi :.. MMMMMMMMMM
 MMMMMMMMMMM  ,, 2S        .i:                         rMM@B@B@MM iMMMM:  MM: MMWB@WM:;::MMW@B@Mr ;M@W@MMMMMMMMMMW@W@W@W@W@W@B@B@W@W@W@W@W@W@W@WWMM                         .:i.        Z7 ,: ,MMMMMMMMMM
 MMMMMMMMMMMM  , Z       ::i:.                        7M@@W@W@W@M; rMMMMM  M,.MMBWB@M2..:MW@B@WMi ;MWMMM:,     ,8MM@W@W@W@W@W@W@W@W@W@W@W@W@W@W@WWMM                         ,:i,,      ,a :  MMMMMMMMMMM
 MMMMMM  MMMM;  ;7      i:i:,                        rM@@W@W@W@WMM. MM@WMM,,7 ZM@B@WMM, ;M@W@BMM: ZMMM;  .iir;;  ,MMMW@W@W@W@W@W@W@W@W@W@W@W@W@W@WWMM                         ::i:i      X:  MMMMM ,MMMMM
 MMMMMM  :MMMMi r:    .i,i::                        iM@@W@W@W@W@WMi iMWWWMM,;.iMW@B@WM, ;MW@BWMM .MMM; ,MMMMMMMMi  iMMMMW@W@W@B@W@W@W@W@W@W@W@W@W@WWM2                         ::i:i.    ;i rMMMM.  MMMMM
 MMMMMi . aMMMM      ,i:i:.                        .MM@W@W@W@W@W@MM..MMBWWMii::MMW@W@Mi XM@W@BMM. MMX .MMW@W@W@@MMi  ,MMMMMW@W@B@W@W@W@W@W@W@W@W@W@WMMX                         ,,i:i.      MMMM7 . MMMMM
 MMMMM. .  MMMM2 .  ,;::                           MM@W@W@W@W@W@W@M; XM@B@MM.;.7M@B@WMi rMW@WWWMi 7M  MMW@MMW@W@WMMMr: :iBMMMMMMW@W@W@W@W@BWB@W@W@W@WMM;                          .::;,  . MMMMM .. :MMMM
 MMMMM. :. .MMMr   .i.                            XM@W@W@W@W@W@W@WMX iMW@W@Mi .;MW@W@Mr 7M@W@B@M0 7; ;MW@Mi:MMMW@WMMXr:.. ,:MMMMMMMW@W@W@W@MMB@W@W@W@WMM.                           ..i    7MMM  .: ,MMMM
 MMMMM  ,:  MMM         ..                       :MMW@W@W@BWB@W@W@MM ,MMW@WMM: ;M@B@WMM;:MW@BWBMM:. iM@@WM7ii7MMMMM7,rWMM7:  . . iMMBWW@W@BWB@W@W@W@W@WM7                        ,         .MMr .:. ,MMMM
 MMMMMi :,, :MM        .;                        8MW@W@W@BMM@W@W@W@Mr rM@B@WM0  MM@B@WMMiiMW@B@MM. ,MM@W@WMMX  :BMMM8;;irr0i,i777 .MMB@W@W@W@W@W@W@W@W@@M:                       .;.        MM. :., 8MMMM
 MMMMMM  :.  Mi       ,i:.                      :M@@W@W@W@BWB@W@W@WMM, MM@B@WM, aMW@B@WM:iMMW@MMM, MM@B@B@M7.:i  ,iXMMMBS78MMMMMr .MMWB@W@W@W@W@W@W@W@W@MS                       .:i.       XM ..,  MMMMM
 MMMMMMi  :  M:     .,i::                       2M@W@W@W@W@W@W@W@W@WMi ;MW@B@MM :MMW@W@M@:XMMMMi;.:aMW@B@MM: iMMr.. . :, .MMMMrr, 0M@B@W@W@B@W@W@W@W@W@WMM:            rX         ::i,.     ;M .:  MMMMMM
 MMMMMMMi  , Z     ,:i,i                       :MMW@W@W@W@W@W@W@W@W@MM iM@WWW@Mr.rMMWMMMM7rXii.iiXW@W@W@B@WMi ;MMMM8;7X: MM@Ma:r rMMW@W@W@BMB@W@W@W@W@W@WM7         rZ7MM;r:       i:i,.    :8 ,  rMMMMMM
 MMM .MMM;  :Z.   .:i:i.        r7             rMW@W@W@W@W@W@W@W@W@W@M: @M@B@WMMB.;MMM;:ii;:ii0MMMMW@W@W@W@MM. MMWMMMMX rM@WM7;. XMW@W@W@WWMWW@W@W@W@W@W@MM          ,MMMM;        .i:i,.   .Z   MMMM  MM
 MMM  ;MMMM  X    :i:i.       ..XM7ZX          MM@B@W@W@M@W@W@W@W@W@WMM. MM@B@WMM; rMi,ii0@MMMMMW@W@W@W@W@W@Mi 7M@B@WM: rMW@WMM: WM@W@W@W@B@B@W@W@W@W@W@BMMi         XaiMX          .i:i,    S  MMMMi  MM
 MM;   ;MMMM  .  .;::         XaMMM2          ,MMB@W@W@W@W@W@W@W@W@W@WM@  MM@W@WMMi i2MMMMMW@W@W@W@W@W@W@W@WMi rMW@B@M; 7M@B@WM: ;MW@W@W@W@W@W@W@W@W@W@W@WMr         .   i            ::;.  .  MMMMi   MM
 MM7 ,  iMMMM    i,.   .        M2r0,         iMW@W@W@W@W@W@W@W@W@W@W@WMM  MM@W@WMMaZMSiBMM@B@W@W@W@W@W@W@W@MM .MM@@WMr ,MMWB@MM :MMW@W@W@W@W@W@W@W@W@W@B@MM                       .   .:i    MMMM,  . MM
 MMM  :  iMMM   .     i         7   ,         XM@W@W@W@W@W@W@W@W@W@W@W@BMM. @M@W@WMMMM8,::MM@W@W@W@W@W@W@W@WWM8 .SMMMM; rM@B@W@M; rM@B@W@W@W@W@W@W@W@W@W@BMM                       .i     .   MMM, .,  MM
 MMM  ,:  rMM        i:.                      7MW@W@W@W@W@W@W@W@W@W@W@B@WMM. MW@W@W@W@MM@i,MM@W@W@W@W@W@W@W@WMa;.,,rMX  @MW@W@WM7 ,MMWW@W@W@W@W@W@W@W@W@BWMM.                      ,ii        MMi .:.  MM
 MMM; ,.:  MM       ::i                       MM@B@W@W@W@W@W@W@W@W@W@MWBWWMa :MW@W@B@W@WMMi:MW@W@W@W@W@W@WMMMMM7X;. . .:ZM@W@W@MX iM@B@W@W@W@W@W@W@W@W@W@B@M:        .r  M.        .i::       MM  :.. MMM
 MMMM  ,., rM      ::i,.       .              MMBWW@W@W@W@W@W@W@W@W@BWBWB@WM.,MMW@W@W@W@WMW:2MW@W@W@W@W@WMS;:i:;i7S8i;MMM@W@W@WM, rMW@W@W@W@W@W@W@W@W@W@W@WM:         iMMMS7:      .::::      M: :., :MMM
 MMMMM  ..  M     :::::        :a  ;,         MM@B@W@W@BWB@W@W@W@W@W@BMMWB@M; MM@W@W@W@W@WMi;M@W@W@W@W@W@Mi:;rMMMMMMMMMW@W@W@WMM .M@@W@W@W@W@W@W@W@W@W@W@B@Mi         ,MMMM;:       ::::,    .M ... :MMMM
 MMMMMMi    2,   .,i:i         rMMMr          8MW@W@W@BMMWW@W@W@W@W@W@BWB@WMM :MW@W@W@W@W@M;,MM@W@W@W@W@W@MMMM@@W@W@W@W@W@W@WMM: BM@W@W@W@W@W@W@W@W@W@W@BWMM,        .X. Mi          i:i,    i2    rMMMMM
 MMMMMMMM   a:.  .i:i        :2MMMMr          XM@W@W@W@BWB@W@W@W@W@W@W@W@W@WM:,MMWWW@W@W@WMM:,MW@W@W@W@W@W@W@W@W@W@B@W@W@W@W@MX :MMW@W@W@W@W@W@W@W@W@W@W@BMM.             ,          .i,i   .iS  .MMMMMMM
 MM  MMMMMB  .   ::i            Mr X:         rMW@W@W@W@BMB@W@W@W@W@W@W@W@W@Mr iMMB@W@W@W@WMW::M@@W@W@W@W@W@W@W@W@W@W@W@W@W@WM, rMW@W@W@W@W@W@W@B@W@W@W@B@MM                           i::      MMMMMM  M
 MM.  rMMMMM. . .::   ,         ;             ;MMW@W@W@W@B@W@W@W@W@W@W@W@W@WMM: MM@B@W@W@W@WMBiiM@@W@W@W@W@W@W@W@W@W@W@W@W@WMa :M@@W@W@W@W@W@W@BMB@W@W@W@WMX                        ,   i:  . iMMMMMi  .M
 MMi   .MMMMM:   .   .:,                       MM@W@W@W@W@W@W@W@W@W@W@W@W@W@WM; iMW@W@W@W@W@WMr:iMM@W@W@W@W@W@W@W@W@W@W@W@W@Mi 7M@W@W@W@W@W@W@W@B@W@W@W@W@M7             :         ::    .   7MMMMM    7M
 MMM  ,  ;MMMi       ,i.                       2MW@W@W@W@W@W@W@W@W@W@W@W@W@W@WM: MMW@W@W@W@W@WMi::MMMW@W@W@W@W@W@W@W@W@W@B@MM ,MMW@W@W@W@W@W@W@W@W@W@W@W@@M,         Sr M;         :i.       7MMM:  ,  MM
 MMM  .:  ,MMS       i::             .         rM@W@W@W@W@W@W@W@W@W@W@W@W@W@W@MM :MMW@W@W@W@W@WMB:,;MMW@W@W@W@W@W@W@W@W@B@WMi iMW@W@W@W@W@W@W@W@W@W@W@W@WMM          ,MMMa:.       i:i       MMM   ,. ,MM
 MMMM  .,.  MM      :,i,         M,.Z.          MM@W@W@W@W@W@W@W@W@W@W@W@W@W@W@Mr ;M@W@W@W@W@W@WMMa.,iMM@W@W@W@W@W@W@W@BWWMM  MM@B@W@W@W@W@W@B@B@W@W@W@W@Mr         iaMMM7X:      .:i::     .MM  .,.  MMM
 MMMM7  .:. iM.    .::::         MMMM           7MW@W@W@W@W@W@W@W@W@W@W@W@W@W@WMM: MM@W@W@W@W@W@W@MM: ,MM@W@W@W@BWB@W@W@WMM, SM@MWW@W@W@W@W@WWMWW@W@W@W@MM          .  ;a          i:i:.    :M. .:.  MMMM
 MMMMMS   ,  aX    .i,i.       raZMMa2:         ,MMW@W@W@W@W@W@W@W@W@W@W@W@W@W@WMM..MW@W@W@W@W@W@W@MMi, MM@W@W@W@MMB@W@WMM, ;MWWMB@W@W@W@W@W@BMB@W@W@W@WMr              ,          ,i,i.    ZX .,   MMMMM
 MMMMMMM,    ,8.   ::i:           M:             XM@W@W@W@W@W@W@W@W@W@W@W@W@W@W@WMi ;MW@W@W@W@W@W@W@WMM..MW@W@W@BWB@W@WMM. rMMW@B@W@W@W@W@W@W@B@W@W@W@WMM.                         .,i:,   .M     iMMMMMM
 MMMMMMMMM;   ai.  ,i:. .         ,               MM@W@W@W@W@W@W@W@W@W@W@W@W@W@W@WM. MMW@W@W@W@W@W@W@WMW,:MW@W@W@B@W@@MW  rMMW@W@W@W@W@W@W@W@W@W@W@W@WMMr                           ,:i.  .7X   rMMMMMMMM
 MMMMM MMMMMM.     ::.   i                        iM@@W@W@W@W@W@W@W@W@W@W@W@W@W@W@MM ,MMW@B@B@W@W@W@W@WM:iM@W@W@W@B@MMi  MMMW@W@W@W@W@W@W@W@W@B@W@W@W@MZ                         i   ,i,     :MMMMMM MMMM
 MMMMM  :MMMMMM,    .   ,i,                        7MB@W@W@W@W@W@W@W@W@W@W@W@W@W@W@MX iMMW@MWW@W@W@W@W@WMM@W@W@W@W@MM: .MM@W@W@W@W@W@W@W@W@W@BMB@W@W@MM.                        ::.   .    :MMMMMM,  MMMM
 MMMMM.   .MMMMM,       ,i:.                        MMW@B@W@W@W@W@W@B@W@W@W@W@W@W@WMM; rMWWMB@W@W@W@W@W@W@W@W@W@W@MM. ;MM@W@W@W@W@W@W@W@W@W@WWMWW@W@@M:                        .:i.       ;MMMMM    iMMMM
 MMMMMM      MMMM       ::i.                        .MMWWM@W@W@W@W@BMB@W@W@W@W@W@W@WMM: ZMMW@B@W@W@W@W@W@W@W@W@W@WMi ;M@@W@W@W@W@W@W@W@W@W@W@B@B@W@@M;                         ,i::       MMM7      MMMMM
 MMMMMM7 ...   MM:     .,:,:                         ,MMWWB@W@W@W@W@B@W@W@W@W@W@W@W@WMM: 7MMW@W@W@W@W@W@W@W@W@W@B@Mi 7M@W@W@W@W@W@W@W@W@W@W@W@W@W@@M7                          ::i,      rMM   ,.  MMMMMM
 MMMMMMM; ..,   MM      i,i,                          :MMW@W@W@W@BWB@W@W@W@W@W@W@W@W@WMM: ;MMMMMMMMW@W@W@W@W@W@W@WM: rMW@W@W@W@W@W@W@BWB@W@W@W@W@@M7                          .,i:i     .MS  .,.  7MMMMMM
 MMMMMMMMr   ,.  ZX    .,:::                           :MMB@W@W@WWMWW@W@W@W@W@W@W@W@W@WMM. i,;i;r;;MW@W@W@W@W@W@BMMi 7M@B@W@W@W@W@W@BMM@W@W@W@W@@M7                            ::i,     a2 ..,   SMMM  MM
 MMMMMMMMMM     . Z:.   ::i                             .MMW@W@W@BMB@W@W@W@W@W@W@W@W@BWMM :M;:i.iiiM@W@W@W@W@W@BWMM. MMB@W@W@W@W@W@W@BWB@W@W@W@MM;                              i:i   .;2 .    .MMMMMMiMM
 MMMMMMMMMMMMi     a..  ,;.  :,                           aM@@W@W@B@W@W@W@W@W@W@W@BWB@B@M, MMMMMMMM@W@W@W@W@W@W@BMM  MMWB@W@W@W@W@W@W@W@W@W@WMMM:                           ,,  ,;.  ..2     iMMMMMM,:,MM
 MMMMMMMMMMMMMMM7:      .:   .;.                           rMM@W@W@W@W@W@W@W@W@W@BMMWB@WMi iMW@W@W@W@W@W@W@W@W@BWMM  MMB@W@W@W@W@W@W@W@W@W@WMMM                            ,;   .:.      :7MMMMMMMMM;,MMM
 MMMMMMMMMM.MMMMMMMX:    .   ,:i.                           ,MMMW@W@W@W@W@W@W@W@W@BMB@B@MM iM@BMB@W@W@W@W@W@W@W@BMM  MMWB@W@W@W@W@W@W@W@W@WMM7                            ,i:.   .    :2MMMMMMM,MM:  MMMM
 MMMMMMMMMM   rMMMMMMM       .i:i                             XMM@@W@W@W@W@W@W@W@W@B@W@WMM.:MWWMWW@W@W@W@W@W@W@BWMM  MMB@W@W@W@W@W@W@W@W@MMM:                             i:i        MMMMMMM;   MMMMiMMMM
 MMMMMMMMMMM     iMMMMr      ,::::                             :aMMMW@W@W@W@W@W@W@W@W@B@M7 rM@BWB@W@W@W@W@W@W@W@BMM. MMWB@W@W@W@W@W@W@WMMMi                              :,::.      XMMM0:     MM  iMMMMM
 MMMMMMMMMMM7       ;MM;      i,i,                               :MMM@@W@W@W@W@W@W@W@W@WMi.7MW@W@W@W@W@W@W@W@W@BWMM. MMB@W@W@W@W@W@W@MMM7                               .,i,i      XMM;       MMMM;,MMMMM
 MMMMMMMMMMMMX  .,    7M;     ,i::                                 iWMMMW@W@B@W@W@W@W@B@Mi.MM@B@W@W@W@W@W@W@W@WWB@M: MMWB@W@W@W@W@WMMM;.                                 i:i,     XM;  ..,   MM; ::MMMMMM
 MMMMMMMMMMMMMM   ,.,   M;    ,:i,  ,                                :XMMMMW@W@B@W@W@W@MM ,MMW@W@W@W@W@W@W@W@W@W@MM, MMBWB@W@W@WMMMM;                                 .  ,i:.    78   ,.,   MMMir,;MMMMMM
 MMMMMMMMMMMMMMM;    .   ar.   ii,  .i                                 ,;MMMMMW@W@W@B@B@M, MMMW@W@W@W@W@W@W@W@MMMM;  MMWB@W@WMMMMX:                                 .i.  ,::   .XS   .    7MMMM.MMMMMMMMM
 MMMMMMMMMMMMMMMMMM:.     r     i   .:i.                   rX             :rMMMMMW@W@W@WM2  iaMMMMMMMMMMMMMMMMM;i  .MM@W@WMMMMXi.                                  ,;,    i     i     .:MMMMM,BM,MMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMM7r           ::i,              .;X;ZM                :;@MMMMMMW@BMM:   ,,i:;;7;7;;::..   irMMMMMMMMXi.             7ai                    ,i::           r7MMMMMMMMMi  iMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMM:       .i,i.          ,raSMr Mi  .i               .:7SMMMMMMMMMr;::   ... . ..:i7ZMMMMMMM7;.                8;                     ,i,i        :MMMMMMMMMMMMMM; iMMMMMMMMMM
 MMMMMMMMMMMMMMMMMM .MMMMMMMMM;       :i,i          ra   :M0   ZW                    ,i77MMMMMMMMMMMMMMMMMMMMMMMMa7r:.                .: .M7iXa0S               .i,i,       rMMMMMMMM8  MM:;;MMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMM.    .i7MMMMS      ,::::               M    M,   X                       ::7rXX2Sa2aS2XXrr::                     .Sar  .X2X;.0Z              ::::.      ZMMMM7:.    iMM,i:BMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMM;        :XMMi     ::i,  ,.          Ma   70  iMM                                                               Mi          a7         .,, .,i:,     :MM7:        MM:rMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMM    , .   7MS     ::i   i:,        ..   M:;X:M.  rB  :.                                                 :ra;  Z88Z0Ma  :aai         ,ii   i::   . SM;   . ,   .MMM, .MMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMM7     ,..  rZ:.   i,    i:i           iMS: :M ,2a. iMXZr                                           ., .M2      .   MX  .         .i:i    ,:   .:2;  ...     MMMMMMSMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMM,         ;     .    .i,i.          :   Mr7S:   Mi  :  7S7r                                     7M  ,M;X:      ;Z            .i,i.    .     ;         :MMMM  MMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMWrr;r;; .          :i,i.             MS.    aM7;   MS .S:   i;r:                  :;S  ,MM7   0,  7M    . a2r            ,i,i,          ..r;r;rrMMMMMMMBMM MMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMi       .:i,i   .               rM      XMi    :0Xr;SZ;   ;M;    Z2   MM..   aX7MX  Z   8Z:XB:            .   i,i:.       iMMMMMMMMMMMMMMMMM  MMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMM:MMMMMMMMMMM.      .,i:: .::              Z0:,     .M8  ,M.     Mi  XMM   XMM   iM ,   :Z  XM2M,   BXi            .i,. ::i,.      ,MMMMMMMMMMM:MMMMMM0M,MMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMM        iiXMMZ;      :i,  .:;:,             ;SX 7;   MX 2M      MS  Z Sa .Z M    M7,    8i   iMS                ::;:   :i,      ;BMM7i:        MMM,MMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM,           r22i.    .i   .:i:i.               .22XXX  ,M     ,M:  M  Mi8  M:   Mi  ,  ;M                    ,i:i:    i.    .iSS;           iMMM:  .MMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.    .., .  .rr,         .,i,i,                       i0Xr;28i  70  :MX  MS   XM7aZ:  .                  .:i,i:          ,;;   . ,..    :MMMS MM:MMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMr                       .,i,i,  ,,,                   :i;,    Xr   i   7X                         ,,.  :i,i,                       .7MMMMMM iMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMr;;r;77MMMMMM:        .i:i.  ,ii::                                                        .:,;:,  .i:i         :MMMMMM77irirrMMMMMMM  :MMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMr,       ::i   .,i:i::                                                   ,,i:i,    ;::       ,rMMMMMMMMMMMMMMMMMMM ;M,.MMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM277SMMMB7i      ..    .i:i:i          OFFICIAL SEAL OF AWESOMENESS          .i:i:i.    ..      i78MMMSr7BMMMMMMMMMMMMMM   MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM              :XX27,           ::i:i.                                             .i:i::           ,7SX7:              MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:      ,., .     ,             ..i:;.                                           .;:i.              .   . . ,..      rMMZ   MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:            irXMMMMi,         .,:                                           i..         ,iMMMMXr:           .;MMMMMM. 2MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM7;r;rrMMMMMMMMMMMMMM2;i                                                         i;2MMMMMMMMMMMMMMrr;r;XMMMMMX   MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM7;7rSSaSaSr                                                   7SaSaSSrr;7MMMMMMMMMMMMMMMMMr:MM..MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMri:                .2X;.                                       .rXS                 :;7MMMMMMM:M,   MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM         ... .    :MMMMMMMMM7;        .:.,       ,.:.       .;2MMMMMMMMM:    . . .        ,MMMMM MM,MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM0:.          :MMMMMMMMMMMMMMMMMr;.  ..r7Sa8Z8aS7r..  .;rMMMMMMMMMMMMMMMM8,          :;MMMMMM M,MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM88Z0MMMMMMMMMMMMMMMMMMMMMMMMMMSi           ;2MMMMMMMMMMMMMMMMMMMMMMMMMMB0MMMMMMM ,M8MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMr;     .,777,.     rrMMMMMMMMMMMMMMMMMMMMMMMMMMMM: MM iMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:ir,        ;MMMMMMMMMMMi       .:riiMMMMMMMMMMMMMMM,M, MM,8MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM       ,iMMMMMMMMMMMMMMMMMMMi.      .MMMMMMMMMMMMM   ZM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:iMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@i;MMMMMMMMMMMMMM:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 
 Project Name: Gravitation
 Version     : Alpha 09.06.17
 Author      : Keith Loughnane
 Contact     : keith.loughnane@gmail.com
 
 Property of Keith Loughnane, All rights reserved.
 Key marks have been placed in code to confirm ownership.
 
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/

#import "rockViewController.h"
#import "math.h"
//#import "NSValue.h"
#include <stdlib.h>

@implementation rockViewController
@synthesize rockImage;
//NSArray scores;
double timeSeconds;
bool locked = false;

/* Parellel arrays reprisedting the bodies */
// Position of the bodies.
double x[255];
double y[255];
// Velocity of the bodies on X and Y axis.
double velx[255];
double vely[255];
double noJoinTime[255];

double noJoin = 5;
// The mass and redius of bodies, r is calculated automaticly from mass.
double mass[255];
double r[255];

bool levelEnd;

//Spawning points
bool spawn;
int spawnX,spawnY;  //Where is the spawn point, where will the rock be created
double spawningVelX, spawningVelY; //what is the velocity of the spawning point
double spawnedVelX, spawnedVelY; //WHat is the velocity of the rock COMING FROM the spawning point;
double spawnTime; //How often do you want a rock to be produced
double spawnTimeLeft;
bool spawnBomb;
int H20Prob, RockProb, IronProb; //Should add upto 255
double spawnedMass;

//ButtonDisableTimes
double zeroWait;
int bombCount;

/* The materials the bodies are made out of, 0.0 mean none of that material
 // if present in the body, 1.0 means it is completly made out of that material
 // regardless of the bodies made up of iron+h20+rock should always add upto 1 */
double iron[255], h20[255], rock[255];
/* Bombs are bodies that explode on contact with anouther body; blowing it into
 // a random(ish) number of pieces adding upto the original mass of the destroyed
 // body  */
bool bomb[255];
/* These views can be tought of like clear animation cells with an image drawn on them
 // rockView holds and image of a body made of 100% rock, h20View holds and image of an
 // icey body, ironView holds an image of an Iron-y body. All 3 views of the same index
 // (eg [100] , rockView[100] , ironView[100] , h20View[100] ) are drawn at the same position
 // with transparency set to reflect the proportion of different materials within the body*/
UIImageView* rockView[255];
UIImageView* ironView[255];
UIImageView* h20View[255];
UIImageView* killBoxView;

UIImageView* BGView;
/* Generaly bodies apply to the laws of physics (applyPhysics=true), but some will not (applyPhysics=false)
 // in that case the body still exerts gravity but is not appected by it. Also if applyPhysics = false
 // That body will not be absorbed by anouther body but will always absorb other bodies in contact regardless
 // of mass. */
bool applyPhysics[255];
/* When the game is paused (paused = true) all physics is paused and a pause/score screen is shown*/
bool paused;
// if the 2 bodies are in contact and over this speed they will not join, very usefull for when a body is
// blown apart, it amoung other things prevents the pieces of the destryed body from instantly reforming
double joinVel = 0.2; 
/* The killBox is an area in which any body that passes into it is destroyed, Usefull for setting up gameplay
 // X1,Y1 is the topleft, X2,Y2 is the bottom right corner and is relitive to scale */
int killBoxX1 =-100;
int killBoxY1 =-100;
int killBoxX2 =-200;
int killBoxY2 =-200;
bool hasTTL[255];
double TTL[255];

// Is the level finished, may be vestigial
bool levelComplete;
// What level are we one
int level;
// normal when a body goes off screen it comes in the other side, sometimes this doesn't look right if a large proportion of the body
// is still on screen, in this case you may want to have a margin outside the screen which the bodie has to go outside of before it
// disappears and reapreas on the other side
int margin;
// Radius of the "Sweet Spot" around the UFO/curser there there is no gravity in effect from the UFO, this means a bodie with low momentom
// will pass trough until it leaves the sweet spot and then gets pulled back in
double noEffectR = 100000.0;
// how zoomed in are we
double scale;
// t is the time used for gravity calculations, reduce to speed the game up, not dynamic.
double t;
// Gravitational constant.
double grav;
// The number of bodies that exist in our universe
int bodies; //gigidy
// Overall gamecounter, reset for each new level.
double game_time;
double old_time;
double app_time;
// Width and hight of the screen for game purpuses
// Most likly this will be the actual screen size minus the control box
int swidth, sheight;
// The point at which the user touched the scrren
double loopInterval;
CGPoint touchPoint;
bool noAppliesGrow; //Do bodies with no physics applied grow on colition
bool curserCanMove;
bool killBoxExists,killOnExit;
bool loading;
bool reloadAfterPause;
double zeroShouldWait;

UIImageView* buttonView[7];

int HSPos1X,HSPos1Y,HSPos2X,HSPos2Y;




UIImage* menuBarImage;
UIImageView* menuBar;

UIImageView* pauseView[20];
UIImageView* pauseAtEndView[20];

NSString *tempString;
NSString *newString;
@synthesize debugText;

double maxSpeed;

bool pauseAfterLoop;
bool chainReact;
bool infiniteBombs;
//int totalLevels;
bool blackHolesEnabled;
bool bombsEnabled;
bool zerosEnabled;
bool loadFromState;
int score;
int maxLevel;
int scores[200];


//NSString *newString;
//NSString *tempString;

- (void)viewDidLoad {
	
	loading =true;
	
	menuBarImage = [UIImage imageNamed:@"MenuBar.png"];
	menuBar = [[UIImageView alloc] initWithImage:menuBarImage];
	
	
	scores[0] = scores[1] = scores[2] = scores[3] =scores[4] = scores[5] =scores[6] = scores[7] =scores[8] = scores[9] = 0;
	maxLevel = 19;
	score = 0;
	loadFromState = true;
	killBoxExists = false;
	killOnExit = false;
	maxSpeed = 20.0;
	bombCount = 0;
	//Full screen size 320 * 480, Menubar is 20Px hi.
	//Setting things up, da-na na-na
	[super viewDidLoad];
	
	//Usefull When Debuging
	//NSString *newString =[[NSString alloc] initWithCString: "Test"];
	// debugText.text = newString;	
	//[newString appendString:@"another string"];	
	
	swidth = 320; sheight = 400; //Usable Screen Size
	timeSeconds = 0; //Time count in seconds	
	//TODO
	pauseView[0].frame = CGRectMake(0, 320, 0, 460);	
	
	bombsEnabled = blackHolesEnabled = zerosEnabled = true;
	
	
	
	
	HSPos1X = 0;
	HSPos1Y = 10;
	HSPos2X = 0;
	HSPos2Y = 160;
	
	
	
	
	buttonView[0].frame = CGRectMake(0, 410, 64, 50);				
	[self.view addSubview:buttonView[0]];
	buttonView[1].frame = CGRectMake(64, 410, 64, 50);				
	[self.view addSubview:buttonView[1]];
	buttonView[2].frame = CGRectMake(128, 410, 64, 50);				
	[self.view addSubview:buttonView[2]];
	buttonView[3].frame = CGRectMake(0, 410, 64, 50);				
	[self.view addSubview:buttonView[3]];
	buttonView[4].frame = CGRectMake(64, 410, 64, 50);				
	[self.view addSubview:buttonView[4]];	
	buttonView[5].frame = CGRectMake(128, 410, 64, 50);				
	[self.view addSubview:buttonView[5]];	
	
	//Setup the images that are going to be used for the run of the game
	
	pauseScreenImage[0] = [UIImage imageNamed:@"pause_screen0.png"];
	pauseScreenImage[1] = [UIImage imageNamed:@"pause_screen1.png"];
	pauseScreenImage[2] = [UIImage imageNamed:@"pause_screen2.png"];
	pauseScreenImage[3] = [UIImage imageNamed:@"pause_screen3.png"];
	pauseScreenImage[4] = [UIImage imageNamed:@"pause_screen4.png"];
	pauseScreenImage[5] = [UIImage imageNamed:@"pause_screen5.png"];
	pauseScreenImage[6] = [UIImage imageNamed:@"pause_screen6.png"];
	pauseScreenImage[7] = [UIImage imageNamed:@"pause_screen7.png"];
	pauseScreenImage[8] = [UIImage imageNamed:@"pause_screen8.png"];
	pauseScreenImage[9] = [UIImage imageNamed:@"pause_screen9.png"];
	pauseScreenImage[10] = [UIImage imageNamed:@"pause_screen10.png"];
		pauseScreenImage[11] = [UIImage imageNamed:@"pause_screen11.png"];
	pauseScreenImage[12] = [UIImage imageNamed:@"pause_screen12.png"];
	pauseScreenImage[13] = [UIImage imageNamed:@"pause_screen13.png"];
	pauseScreenImage[14] = [UIImage imageNamed:@"pause_screen14.png"];
	pauseScreenImage[15] = [UIImage imageNamed:@"pause_screen15.png"];
	pauseScreenImage[16] = [UIImage imageNamed:@"pause_screen16.png"];
	pauseScreenImage[17] = [UIImage imageNamed:@"pause_screen17.png"];
	pauseScreenImage[18] = [UIImage imageNamed:@"pause_screen18.png"];
	pauseScreenImage[19] = [UIImage imageNamed:@"pause_screen19.png"];
	//pauseScreenImage[10] = [UIImage imageNamed:@"pause_screen10.png"];
	
	BGImage = [UIImage imageNamed:@"bg_image_lvl3.png"];
	BGView = [[UIImageView alloc] initWithImage:BGImage];
	[self.view addSubview:BGView];
	
	smallRockImage = [UIImage imageNamed:@"small_rock.png"];
	smallH20Image = [UIImage imageNamed:@"small_h20.png"];	
	smallIronImage = [UIImage imageNamed:@"small_iron.png"];
	//TODO Remove carefully
	largeRockImage = [UIImage imageNamed:@"large_iron.png"];	
	largeH20Image = [UIImage imageNamed:@"large_iron.png"];	
	largeIronImage = [UIImage imageNamed:@"large_iron.png"];
	ironCoreImage = [UIImage imageNamed:@"large_iron.png"];	
	rockMantalImage = [UIImage imageNamed:@"large_iron.png"];	
	H20SurfaceImage = [UIImage imageNamed:@"large_iron.png"];
	
	
	
	magmaImage  = [UIImage imageNamed:@"LavaBall.png"];
	earthlikeImage  = [UIImage imageNamed:@"earthlike.png"];	

	
	ufoImage = [UIImage imageNamed:@"ufo.png"]; //The curser	
	bombImage = [UIImage imageNamed:@"bomb.png"]; //The Nuke
	
	//Images for the buttons
	minusButtonImage = [UIImage imageNamed:@"minus.png"];
	plusButtonImage = [UIImage imageNamed:@"plus.png"];
	playButtonImage = [UIImage imageNamed:@"play.png"];
	pauseButtonImage = [UIImage imageNamed:@"pause.png"];
	zeroButtonImage = [UIImage imageNamed:@"0.png"];
	nukeButtonImage = [UIImage imageNamed:@"nuke.png"];
	blackHoleButtonImage = [UIImage imageNamed:@"RealGravButton.png"];
	killBoxImage = [UIImage imageNamed:@"killbox.png"];
	gravImage = [UIImage imageNamed:@"grav.png"];
	
	for(int i = 0; i<20; i++)
	{
		pauseView[i] = [[UIImageView alloc] initWithImage:pauseScreenImage[i]];
	}
	
	buttonView[0] = [[UIImageView alloc] initWithImage:nukeButtonImage];
	buttonView[1] = [[UIImageView alloc] initWithImage:zeroButtonImage];
	buttonView[2] = [[UIImageView alloc] initWithImage:pauseButtonImage];
	buttonView[6] = [[UIImageView alloc] initWithImage:blackHoleButtonImage];
	
	buttonView[3] = [[UIImageView alloc] initWithImage:minusButtonImage];
	buttonView[4] = [[UIImageView alloc] initWithImage:plusButtonImage];
	buttonView[5] = [[UIImageView alloc] initWithImage:playButtonImage];
	
	
	loopInterval = 0.05; //How often does the game loop run
	//Setting up the timer, This timer runs the game loop.
	[NSTimer scheduledTimerWithTimeInterval:(loopInterval) target:self selector:@selector(onTimer) userInfo:nil repeats:YES];	
	
	chainReact = false;
	
	/* Most of the setup is level specific, if you want to see more of the 
	 // setup follow this method */
	level = 0;
	
	// NSString *newString =[[NSString alloc] initWithCString: ""];
	//newString = [newString stringByAppendingString:@"Big Loop "];	
	//NSString *tempString;	
	//newString = [newString stringByAppendingString:@"\n Bodyno: "];	
	//tempString = [NSString stringWithFormat:@"%i", bodies];	
	//newString = [newString stringByAppendingString:tempString];	
	//debugText.text = newString;
	
	
	UIApplication *app = [UIApplication sharedApplication];
	[[NSNotificationCenter defaultCenter] addObserver: self
											 selector:@selector(applicationWillTerminate:)
												 name:UIApplicationWillTerminateNotification
											   object:app];
	[super viewDidLoad];
	[self LoadOptions];
	[self LoadScores:level];
	//NSLog(@"Scores Done");
	[self LoadLevel :level];
	//NSLog(@"Loading Done");
}
- (void)LoadLevel:(int)levelNumber
/* Resets Values and reinitalises besed on level number, Think of each case as the setup block for variables */
{
	loading = true;
	//NSLog(@"begining load");
	//if(!loadFromState)
	//{
		//NSLog(@"Calling savescores");
	//}
	score = 0;
	levelEnd = false;
	
	if(level>maxLevel)
		level =0;
	if(level < 0)
		level = maxLevel;
	//NSLog(@"trying to remove views 0 to 255 from superview");
	/*for(int i = 0; i < 254; i++)
	{
		[rockView[i] removeFromSuperview];
		[h20View[i] removeFromSuperview];
		[ironView[i] removeFromSuperview];
	}*/

	//NSLog(@"It worked");
	//newString =[[NSString alloc] initWithCString: "Level "];
	//tempString;						
	//tempString = [NSString stringWithFormat:@"%i", level];	
	//newString = [newString stringByAppendingString:tempString];	
	/*************************************************************************************************************
	 * UNLOAD OLD LEVEL and reset everything to default. Don't allow and changes to pass						 *
	 * into the next level																						 *
	 *************************************************************************************************************/
	
	//Remove old bodies one by one
	while(bodies >=1)
	{
		// Bug Warning
		//The body above 1 will be movied down to 1 each time
		//NSLog(@"Destoryed cause clearing");
		[self destroyBody: 1];
	}
	//Remove old Pause, BG screens
	for(int i = 0;i < 20; i++)
	{
		[pauseView[i] removeFromSuperview];
		[pauseAtEndView[i] removeFromSuperview];
	}
	//Clear the curser view
	[ironView[0] removeFromSuperview];
	[h20View[0] removeFromSuperview];
	[rockView[0] removeFromSuperview];
	//Remove Killbox view
	[killBoxView removeFromSuperview];	
	
	//Reset things to their defaults
	//Bug Warning; If levels act oddly after coming out of a different level the problem may be here
	//Reset TTLs
	for(int i = 0; i< 255;i++)
	{
		TTL[i] = 0;
		hasTTL[i] = false;
	}	killBoxView.alpha = 1.0;
	killBoxExists = false;
	zeroWait = 0.0;
	noAppliesGrow = true;
	pauseAfterLoop = true;
	infiniteBombs = false;
	game_time = 0;
	app_time = 0;
	spawn = false;
	killOnExit = false;
	spawnBomb = false;
	curserCanMove = true;
	ufoImage = [UIImage imageNamed:@"ufo.png"]; //The curser
	H20Prob = IronProb = RockProb = 0;	
	
	/***************************************************************************************************************/
	//Big Switch Statement decides which level to load
	/*BUG WARNING any variables not set will be left as is was in the previus level, no not rely on this.
	 *Properly redeclare each time */
	switch (level)
	{
		case 0:
			//case default:
		{
			/********************************************************************************************************
			 * Level 0 is a little demo that runns under the pause screen to give a number inital menu
			 ********************************************************************************************************/
			//tempString =[[NSString alloc] initWithCString: "\nJust Mess around "];
			//newString = [newString stringByAppendingString:tempString];	
			//DONT CHANGE (WITH OUT SERIUS CONSIDERATION) it looks cool
			// ******* The setup for level 0/Main Menu ********
			// Margin at the edge, how far can a body go off screen before it's brought back in	
			scale = 0.03; //0.3 Zoomscale ALWAYS DEFINE SCALE FIRST
			
			
			
			spawn = true;
			spawnX =(swidth/scale)/2;
			spawnY =-10; //(sheight/scale)/2;  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 1;
			spawnedVelY = 1; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 10; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255
			spawnBomb = true;
			
			
			
			
			
			
			
			
			
			killBoxExists = false;
			killBoxX1 = 100/scale;
			killBoxY1 = 100/scale;
			killBoxX2 =200/scale;
			killBoxY2 = 200/scale;
			chainReact = false;
			zeroWait = 0.0;
			zeroShouldWait = 10;
			pauseAfterLoop = true;
			infiniteBombs=false;
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.00 alpha:1.0];
			t=1.0; // Gravity time, esentaly game speed			
			grav = 100; // Gravitational Constant
			bodies = 40; //Number of bodies			
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;
			applyPhysics[0] = true;
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			for (int i = 1; i <= bodies; i++)
			{
				srand(i^2); //TODO may be redunant
				arc4random_stir(); //New Seeds
				x[i] = round(arc4random() % (int)(swidth/scale)); //Place randomly on the x-axis within the screen withscale
				arc4random_stir();//New Seeds
				y[i] = round(arc4random() % (int)(sheight/scale)); //Place randomly on the y-axis within the screen withscale
				rock[i] = h20[i] = iron[i] = 0; //Instanciate matierial values
				applyPhysics[i] = true; //These objects should be effected by physics
				//Randomly make it rock, Ice or Iron
				switch ((int)round(arc4random() % (int)(3)))
				{
					case 0:
						rock[i] = 1;
						break;
					case 1:
						iron[i] = 1;
						break;
					case 2:
						h20[i] = 1;
						break;
					default :
						rock[i] = 1;
						break;
				}
				bomb[i] = false; //Shouldn't explode TODO random explosives for demo
				velx[i] = 0; //No Velocity initanly
				vely[i] = 0;
				mass[i] = 0;
				while(mass[i]<10000)
				{
					arc4random_stir();
					mass[i] = (arc4random() + 10000)%100000;
				}
				r[i] = sqrt(mass[i]); //Make the radius sq root of mass, Shutup! It's cartoony	
				// Setup 3 views for each body
				ironView[i] = [[UIImageView alloc] initWithImage:smallIronImage];
				h20View[i] = [[UIImageView alloc] initWithImage:smallH20Image];
				rockView[i] = [[UIImageView alloc] initWithImage:smallRockImage];
				// Set the opacity for each based on material value
				rockView[i].alpha =rock[i];
				ironView[i].alpha =iron[i];
				h20View[i].alpha =h20[i];
			}
			
			BGView = [[UIImageView alloc] initWithImage:BGImage];
			BGView.alpha = 0;
			[self.view addSubview:BGView];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = true;
			zerosEnabled = true;
			blackHolesEnabled = true;
			noAppliesGrow = false;
			//blac
			break;
		}
			
		case 1:
		{
			
			/**********************************************************************************************************
			 *		Level 1 gives a little demo showing the UFO with a few bodies interacting with it to 
			 *		show the user how it works
			 **********************************************************************************************************/
			//NSLog(@"level 1 part 0");
			curserCanMove = false;			
			//newString = [newString stringByAppendingString:tempString];
			//NSLog(@"level 1 part 0.1");
			scale = 0.11; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			spawn = false;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//NSLog(@"level 1 part 1");
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.00 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 100; // Gravitational Constant
			bodies = 3; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			applyPhysics[0] = false;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			//NSLog(@"level 1 part 2");
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			ufoImage = [UIImage imageNamed:@"ufo_large.png"]; //The curser
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views			
			//Dont fuck with 1 it's in orbit
			x[1] = (swidth/2)/scale;			
			y[1] = (sheight/2)+2/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = true; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			h20[1] = 1.0;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = -3; //No Velocity initanly
			vely[1] = 1;			
			mass[1] = 5000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			
			rock[1] = 0.0;
			h20[1] = 0.0;
			iron[1] = 1.0;
			
			
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			applyPhysics[1] = true;
			
			//NSLog(@"level 1 part 3");
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];			
			x[2] = (swidth/scale)/2;			
			y[2] = (sheight/scale)/2;
			velx[2] = -.5;
			vely[2] = .5;
			rock[2] = h20[2] = iron[2] = 0; //Instanciate matierial values
			applyPhysics[2] = true; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[2] = 0.0;
			h20[2] = 1.0;
			iron[2] = 0.0;			
			bomb[2] = false; //Shouldn't explode TODO random explosives for demo			
			mass[2] = 3000;
			r[2] = sqrt(mass[2]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[2] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[2] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[2] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[2].alpha =rock[2];
			ironView[2].alpha =iron[2];
			h20View[2].alpha =h20[2];			
			x[bodies] = 100;			
			y[bodies] = 100;
			//NSLog(@"level 1 part 4");
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = true; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[bodies] = 1.0;
			h20[bodies] = 0.0;
			iron[bodies] = 0.0;			
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 10000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[bodies].alpha =rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];
			killOnExit = false;
			//NSLog(@"level 1 part 5");
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			
			
			bombsEnabled = false;
			zerosEnabled = false;
			blackHolesEnabled = false;
			
			
			
			break;
		}// end of level 6 setup
			
			
			//***  Add level like level 1 but the user can move the body  ***
			
			
		case 2:
		{
			//NSLog(@"level 2 part 0");
			//tempString =[[NSString alloc] initWithCString: "\nPlace the ufo on the X, Be carfull it'll drift"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.07; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			spawn = true;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255
			spawnBomb = false;
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			ufoImage = [UIImage imageNamed:@"ufo_large.png"]; //The curser
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views	
			x[bodies] = 1;			
			y[bodies] = 1;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[bodies] = 0.0;	
			iron[bodies] = 1.0;
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 1000000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			
			
			BGView = [[UIImageView alloc] initWithImage:BGImage];				
			
			
			
			// Set the opacity for each based on material value
			rockView[bodies].alpha =1;//rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];
			
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			
			
			break;
		}// end of level 6 setup
		case 3:
		{
			//NSLog(@"level 3 part 0");
			//tempString =[[NSString alloc] initWithCString: "\nNow do it on your own"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.05; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			spawn = true;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255
			spawnBomb = false;
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			H20Prob = 0.0;
			IronProb =0.0;
			RockProb = 1.0;
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed
			
			grav = 300; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;
			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views
			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			/*for (int i = 1; i <= bodies; i++)
			 {*/
			
			x[bodies] = 300/scale;
			
			y[bodies] = 1000;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron
			
			rock[bodies] = 1;
			
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;
			h20[bodies] = iron[bodies] = rock[bodies] = 0.0;
			h20[bodies] = 1.0;
			mass[bodies] = 1000000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[bodies].alpha =rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];
			
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			spawningVelY =  0;
			spawningVelX = -10;
			
			
			
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			
			
			break;
		}// end of level 6 setup
		case 4:
		{
			//NSLog(@"level 4 part 0");
			//tempString =[[NSString alloc] initWithCString: "\nGet Only RED astoriods into the planetoid"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.05; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			spawn = true;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255
			H20Prob = 50;
			RockProb = 0;
			IronProb = 50;
			spawnBomb = false;
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views
			x[bodies] = 300/scale;			
			y[bodies] = 1000;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			iron[bodies] = 1;			
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 1000000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[bodies].alpha =rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 1.0;
			rockView[0].alpha = 0.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			break;
		}// end of level 6 setup
		case 5:
		{
			//tempString =[[NSString alloc] initWithCString: "\nGet 5things into each thing "];
			//newString = [newString stringByAppendingString:tempString];		
			scale = 0.05; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			spawn = true;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;			
			spawningVelX = 10;
			spawningVelY = 0;
			
			H20Prob = 50;
			RockProb = 0;
			IronProb = 50;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.00 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 2; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = 300/scale;			
			y[1] = 20/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			h20[1] = 1;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = 0; //No Velocity initanly
			vely[1] = 0;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];			
			x[bodies] = 1000;			
			y[bodies] = 1000;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			iron[bodies] = 1;			
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 1000000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[bodies].alpha =rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			break;
		}// end of level 6 setup
		case 6:
		{
			//tempString =[[NSString alloc] initWithCString: "\nGet 5things into each thing spawn moving"];
			//newString = [newString stringByAppendingString:tempString];		
			scale = 0.05; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			spawn = true;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			spawningVelX = 10;
			spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 2; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;			
			spawningVelX = 10;
			spawningVelY = 0;
			H20Prob = 100;
			RockProb =100;
			//IronProb =100;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 2; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			rock[1] = 0.0;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = 300/scale;			
			y[1] = 20/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = 0; //No Velocity initanly
			vely[1] = 0;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];			
			x[bodies] = 1000;			
			y[bodies] = 1000;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			
			h20[bodies] = 1.0;				applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			//rock[bodies] = 1;			
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 1000000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[bodies].alpha =rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			
			break;
		}// end of level 6 setup
		case 7:
		{
			//tempString =[[NSString alloc] initWithCString: "\nGet 5things into each thing "];
			//newString = [newString stringByAppendingString:tempString];		
			scale = 0.05; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			spawn = true;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			spawningVelX = 15;
			//spawningVelY =10; //what is the velocity of the spawning point
			//spawnedVelX = 0;
			//spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 1.5; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			
			spawnedVelX = 0;
			spawnedVelY = -10;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;	
			RockProb =100;
			IronProb =100;
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 2; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];		
			//Setup Button Views			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = 300/scale;			
			y[1] = 20/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[1] = 1;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = 0; //No Velocity initanly
			vely[1] = 0;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];			
			x[bodies] = 1000;			
			y[bodies] = 1000;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			iron[bodies] = 1;			
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 1000000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[bodies].alpha =rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			break;
		}// end of level 6 setup
			/*case 8:
			 {
			 tempString =[[NSString alloc] initWithCString: "\nGet 5things into each thing "];
			 newString = [newString stringByAppendingString:tempString];		
			 scale = 0.05; // Zoomscale
			 pauseAfterLoop = true;
			 killBoxExists = false;
			 spawn = true;
			 spawnX = (swidth/scale)/2;
			 spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			 //spawningVelX = 10;
			 //spawningVelY =10; //what is the velocity of the spawning point
			 spawnedVelX = 0;
			 spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			 spawnTime = 3; //How often do you want a rock to be produced
			 spawnTimeLeft =0;
			 spawnedMass = 100000;			
			 spawningVelX = 10;
			 spawningVelY = 0;
			 //int H20Prob, RockProb, IronProb; //Should add upto 255			
			 // Margin at the edge, how far can a body go off screen before it's brought back in			
			 margin = 10;			
			 paused = false;// Not paused
			 // BG Colour 0.0 to 1.0
			 self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			 t=.5; // Gravity time, esentaly game speed			
			 grav = 100; // Gravitational Constant
			 bodies = 2; //Number of bodies
			 noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			 //Place the UFO at the center of the screen
			 x[0] = (swidth/scale)/2;
			 y[0] = (sheight/scale)/2;			
			 //Instansiating is just good practice
			 velx[0] = 0;
			 vely[0] = 0;
			 //How heavy is our UFO
			 mass[0] = 1000000;
			 killOnExit = true;
			 // The size of our UFO
			 r[0] = 1000;
			 //Setup the UFO View with UFO image
			 rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			 //Setup Button Views			
			 //Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			 x[1] = 300/scale;			
			 y[1] = 20/scale;
			 rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			 applyPhysics[1] = false; //These objects should be effected by physics
			 //Randomly make it rock, Ice or Iron			
			 rock[1] = 1;			
			 bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			 velx[1] = 0; //No Velocity initanly
			 vely[1] = 0;			
			 mass[1] = 1000000;
			 r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			 // Setup 3 views for each body
			 ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			 h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			 rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			 // Set the opacity for each based on material value
			 rockView[1].alpha =rock[1];
			 ironView[1].alpha =iron[1];
			 h20View[1].alpha =h20[1];			
			 x[bodies] = 1000;			
			 y[bodies] = 1000;
			 rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			 applyPhysics[bodies] = false; //These objects should be effected by physics
			 //Randomly make it rock, Ice or Iron			
			 rock[bodies] = 1;			
			 bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			 velx[bodies] = 0; //No Velocity initanly
			 vely[bodies] = 0;			
			 mass[bodies] = 1000000;
			 r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			 // Setup 3 views for each body
			 ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			 h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			 rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			 // Set the opacity for each based on material value
			 rockView[bodies].alpha =rock[bodies];
			 ironView[bodies].alpha =iron[bodies];
			 h20View[bodies].alpha =h20[bodies];
			 break;
			 }// end of level 6 setup*/
			
		case 8:
		{
			//tempString =[[NSString alloc] initWithCString: "\nget 5 things into the thing"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.05; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = true;
			killBoxX1 = 150/scale;
			killBoxY1 = 390/scale;
			killBoxX2 = 190/scale;
			killBoxY2 = 450/scale;
			killBoxView.frame = CGRectMake(killBoxX1, killBoxY1,killBoxX1-killBoxX2,killBoxY1-killBoxY2);	
			[self.view addSubview:killBoxView];
			[self.view addSubview:buttonView[0]];
			spawn = true;
			spawnX = (swidth/2)/scale;//(swidth/scale)/2;
			spawnY = 0;  //Where is the spawn point, where will the rock be created
			spawningVelX = 0;
			spawningVelY =0; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = 10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 0; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			//x[1] = 300/scale;			
			//y[1] = 20/scale;
			//rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			//applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			//rock[1] = 1;			
			//bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			//velx[1] = 0; //No Velocity initanly
			//vely[1] = 0;			
			//mass[1] = 1000000;
			//r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			//ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			//h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			//rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			killBoxView = [[UIImageView alloc] initWithImage:killBoxImage];
			killBoxView.alpha = 1.0;		
			// Set the opacity for each based on material value
			//rockView[1].alpha =rock[1];
			//ironView[1].alpha =iron[1];
			//h20View[1].alpha =h20[1];
			//x[bodies] = 310/scale;
			///y[bodies] = 10;
			//rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			//applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron
			//rock[bodies] = 1;
			//bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			//velx[bodies] = 0; //No Velocity initanly
			//vely[bodies] = 0;
			//mass[bodies] = 1000000;
			//r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			//ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			//h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			//rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			//rockView[bodies].alpha =rock[bodies];
			//ironView[bodies].alpha =iron[bodies];
			//h20View[bodies].alpha =h20[bodies];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = true;
			zerosEnabled = true;
			blackHolesEnabled = false;
			
			break;
		}// end of level 6 setup
		case 9:
		{
			//tempString =[[NSString alloc] initWithCString: "\nget 5 things into the thing"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.05; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = true;
			killBoxX1 = 150/scale;
			killBoxY1 = 400/scale;
			killBoxX2 = 190/scale;
			killBoxY2 = 450/scale;
			killBoxView.frame = CGRectMake(killBoxX1, killBoxY1,killBoxX1-killBoxX2,killBoxY1-killBoxY2);	
			[self.view addSubview:killBoxView];
			[self.view addSubview:buttonView[0]];
			spawn = true;
			spawnX = (swidth/2)/scale;//(swidth/scale)/2;
			spawnY = 0;  //Where is the spawn point, where will the rock be created
			spawningVelX = 3;
			spawningVelY =0; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = 5; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed
			grav = 300; // Gravitational Constant
			bodies = 0; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			//killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			//x[1] = 300/scale;			
			//y[1] = 20/scale;
			//rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			//applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron
			//rock[1] = 1;			
			//bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			//velx[1] = 0; //No Velocity initanly
			//vely[1] = 0;			
			///mass[1] = 1000000;
			//r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			//ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			//h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			//rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			killBoxView = [[UIImageView alloc] initWithImage:killBoxImage];
			killBoxView.alpha = 1.0;			
			// Set the opacity for each based on material value
			//rockView[1].alpha =rock[1];
			//ironView[1].alpha =iron[1];
			//h20View[1].alpha =h20[1];			
			//x[bodies] = 310/scale;			
			//y[bodies] = 10;
			//rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			//applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			//rock[bodies] = 1;			
			///bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			//velx[bodies] = 0; //No Velocity initanly
			//vely[bodies] = 0;			
			//mass[bodies] = 1000000;
			//r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			//ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			//h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			//rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			//rockView[bodies].alpha =rock[bodies];
			//ironView[bodies].alpha =iron[bodies];
			//h20View[bodies].alpha =h20[bodies];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = true;
			zerosEnabled = true;
			blackHolesEnabled = false;
			break;			
		}// end of level 6 setup
		case 10:
		{
			//tempString =[[NSString alloc] initWithCString: "\nget 5 things into the thing"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.04; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = true;
			killBoxX1 = 150/scale;
			killBoxY1 = 400/scale;
			killBoxX2 = 190/scale;
			killBoxY2 = 450/scale;
			killBoxView.frame = CGRectMake(killBoxX1, killBoxY1,killBoxX1-killBoxX2,killBoxY1-killBoxY2);	
			[self.view addSubview:killBoxView];
			[self.view addSubview:buttonView[0]];
			spawn = true;
			spawnX = (swidth/2)/scale;//(swidth/scale)/2;
			spawnY = 0;  //Where is the spawn point, where will the rock be created
			spawningVelX = 10;
			spawningVelY =0; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = 8; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 1.5; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255
			H20Prob = 50;
			RockProb = 50;
			RockProb = 50;
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 0; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];		
			//Setup Button Views			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			//x[1] = 300/scale;			
			//y[1] = 20/scale;
			//rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			//applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			//rock[1] = 1;			
			///bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			//velx[1] = 0; //No Velocity initanly
			//vely[1] = 0;			
			//mass[1] = 1000000;
			//r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			//ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			//h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			//rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			killBoxView = [[UIImageView alloc] initWithImage:killBoxImage];
			killBoxView.alpha = 1.0;
			// Set the opacity for each based on material value
			//rockView[1].alpha =rock[1];
			//ironView[1].alpha =iron[1];
			//h20View[1].alpha =h20[1];			
			//x[bodies] = 310/scale;			
			//y[bodies] = 10;
			//rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			//rock[bodies] = 1;			
			//bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			//velx[bodies] = 0; //No Velocity initanly
			//vely[bodies] = 0;			
			//mass[bodies] = 1000000;
			//r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			//ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			//h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			//rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			//rockView[bodies].alpha =rock[bodies];
			//ironView[bodies].alpha =iron[bodies];
			//h20View[bodies].alpha =h20[bodies];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = true;
			zerosEnabled = true;
			blackHolesEnabled = false;
			killOnExit =false;
			break;
		}// end of level 6 setup			
		case 11:
		{
			//tempString =[[NSString alloc] initWithCString: "\nget 5 things into the thing"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.03; // Zoomscale
			pauseAfterLoop = true;
			//killBoxExists = true;
			killBoxX1 = 150/scale;
			killBoxY1 = 400/scale;
			killBoxX2 = 190/scale;
			killBoxY2 = 450/scale;
			killBoxView.frame = CGRectMake(killBoxX1, killBoxY1,killBoxX1-killBoxX2,killBoxY1-killBoxY2);	
			[self.view addSubview:killBoxView];
			[self.view addSubview:buttonView[0]];
			spawn = true;
			spawnX = (swidth/2)/scale;//(swidth/scale)/2;
			spawnY = 0;  //Where is the spawn point, where will the rock be created
			spawningVelX = 0;
			spawningVelY =0; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = 10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			H20Prob = 0;
			IronProb =0;
			RockProb =100;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 0;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			//[rockView[0] removeFromSuperview];
			//Setup Button Views		
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = ((swidth/2)-50)/scale;			
			y[1] = 300/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[1] = 1;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = 0; //No Velocity initanly
			vely[1] = 0;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			killBoxView = [[UIImageView alloc] initWithImage:killBoxImage];
			killBoxView.alpha = 1.0;			
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			noAppliesGrow =true;
			break;
		}// end of level 6 setup	
		case 12:
		{
			H20Prob = 100;
			IronProb =100;
			RockProb =0;
			//tempString =[[NSString alloc] initWithCString: "\nget 5 things into the thing"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.03; // Zoomscale
			pauseAfterLoop = true;
			//killBoxExists = true;
			killBoxX1 = 150/scale;
			killBoxY1 = 400/scale;
			killBoxX2 = 190/scale;
			killBoxY2 = 450/scale;
			killBoxView.frame = CGRectMake(killBoxX1, killBoxY1,killBoxX1-killBoxX2,killBoxY1-killBoxY2);	
			[self.view addSubview:killBoxView];
			[self.view addSubview:buttonView[0]];
			spawn = true;
			spawnX = ((swidth/10)*6)/scale;//(swidth/scale)/2;
			spawnY = 0;  //Where is the spawn point, where will the rock be created
			spawningVelX = 0;
			spawningVelY =0; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = 10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 0;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			//[rockView[0] removeFromSuperview];
			//Setup Button Views		
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = ((swidth/2)-50)/scale;			
			y[1] = 300/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			iron[1] = 1;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = 0; //No Velocity initanly
			vely[1] = 0;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			killBoxView = [[UIImageView alloc] initWithImage:killBoxImage];
			killBoxView.alpha = 1.0;			
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 0.0;
			h20View[0].alpha = 0.0;
			
			
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			noAppliesGrow =true;
			break;
		}// end of level 6 setup	
		case 13:
		{
			//tempString =[[NSString alloc] initWithCString: "\nget 5 things into the thing"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.03; // Zoomscale
			pauseAfterLoop = true;
			//killBoxExists = true;
			killBoxX1 = 150/scale;
			killBoxY1 = 400/scale;
			killBoxX2 = 190/scale;
			killBoxY2 = 450/scale;
			killBoxView.frame = CGRectMake(killBoxX1, killBoxY1,killBoxX1-killBoxX2,killBoxY1-killBoxY2);	
			[self.view addSubview:killBoxView];
			[self.view addSubview:buttonView[0]];
			spawn = true;
			spawnX = ((swidth/3)*2)/scale;//(swidth/scale)/2;
			spawnY = 0;  //Where is the spawn point, where will the rock be created
			spawningVelX = 0;
			spawningVelY =0; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = 10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 0;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			//[rockView[0] removeFromSuperview];
			//Setup Button Views		
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = ((swidth/2)-50)/scale;			
			y[1] = 300/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			h20[1] = 1;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = 0; //No Velocity initanly
			vely[1] = 0;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			killBoxView = [[UIImageView alloc] initWithImage:killBoxImage];
			killBoxView.alpha = 1.0;			
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			H20Prob = 100;
			IronProb = 100;
			RockProb =0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			noAppliesGrow =true;
			break;
		}// end of level 6 setup	
		case 14:
		{
			//tempString =[[NSString alloc] initWithCString: "\nGet 5things into each thing "];
			//newString = [newString stringByAppendingString:tempString];		
			scale = 0.03; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			//spawn = true;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;			
			spawningVelX = 10;
			spawningVelY = 0;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 3; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = false;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = 300/scale;			
			y[1] = 20/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			h20[1] = 1;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = 0; //No Velocity initanly
			vely[1] = 0;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];			
			x[2] = 1000;			
			y[2] = 1000;
			rock[2] = h20[2] = iron[2] = 0; //Instanciate matierial values
			applyPhysics[2] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			iron[2] = 1;			
			bomb[2] = false; //Shouldn't explode TODO random explosives for demo
			velx[2] = 0; //No Velocity initanly
			vely[2] = 0;			
			mass[2] = 1000000;
			r[2] = sqrt(mass[2]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[2] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[2] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[2] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[2].alpha =rock[2];
			ironView[2].alpha =iron[2];
			h20View[2].alpha =h20[2];			
			x[3] = (swidth/2)/scale;			
			y[3] = (sheight/2)/scale;
			rock[3] = h20[3] = iron[3] = 0; //Instanciate matierial values
			applyPhysics[3] = true; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			iron[3] = .5;
			h20[3] = .5;			
			bomb[3] = false; //Shouldn't explode TODO random explosives for demo
			velx[3] = 0; //No Velocity initanly
			vely[3] = 0;			
			mass[3] = 1000000;
			r[3] = sqrt(mass[3]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[3] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[3] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[3] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[3].alpha =rock[3];
			ironView[3].alpha =iron[3];
			h20View[3].alpha =h20[3];
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = true;
			zerosEnabled = true;
			blackHolesEnabled = false;
			break;
		}// end of level 6 setup			
		case 16:
		{
			noAppliesGrow = true;
			//tempString =[[NSString alloc] initWithCString: "\nget 5 things into the thing"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.03; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = true;
			killBoxX1 = 120/scale;
			killBoxY1 = 300/scale;
			killBoxX2 = 320/scale;
			killBoxY2 = 350/scale;
			killBoxView.frame = CGRectMake(killBoxX1, killBoxY1,killBoxX1-killBoxX2,killBoxY1-killBoxY2);	
			[self.view addSubview:killBoxView];
			[self.view addSubview:buttonView[0]];
			spawn = true;
			spawnX = 310/scale;//(swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			spawningVelX = 0;
			spawningVelY =0; //what is the velocity of the spawning point
			spawnedVelX = -10;
			spawnedVelY = 0; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.05 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = 300/scale;			
			y[1] = 20/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[1] = 1;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = 0; //No Velocity initanly
			vely[1] = 0;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			killBoxView = [[UIImageView alloc] initWithImage:killBoxImage];
			killBoxView.alpha = 1.0;			
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];			
			x[bodies] = 310/scale;			
			y[bodies] = 10;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			iron[bodies] = 1;			
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 10000000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[bodies].alpha =rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];
			
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 1.0;
			rockView[0].alpha = 0.0;
			h20View[0].alpha = 0.0;
			
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = true;
			break;
		}// end of level 6 setup		
		case 15:
		{
			noAppliesGrow =true;
			//tempString =[[NSString alloc] initWithCString: "\nget 5 things into the thing\n using only blackholes"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.03; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = true;
			killBoxX1 = 220/scale;
			killBoxY1 = 120/scale;
			killBoxX2 = 320/scale;
			killBoxY2 = 350/scale;
			killBoxView.frame = CGRectMake(killBoxX1, killBoxY1,killBoxX1-killBoxX2,killBoxY1-killBoxY2);	
			[self.view addSubview:killBoxView];
			[self.view addSubview:buttonView[0]];
			spawn = true;
			spawnX = 310/scale;//(swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = -10;
			spawnedVelY = 0; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255		 
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.05 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed		 
			grav = 300; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;		 
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];		
			//Setup Button Views		 
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = 150/scale;			
			y[1] = 20/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			iron[1] = 1;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = 0; //No Velocity initanly
			vely[1] = 0;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			killBoxView = [[UIImageView alloc] initWithImage:killBoxImage];
			killBoxView.alpha = 1.0;			
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];			
			x[bodies] =150/scale;			
			y[bodies] = 10;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			iron[bodies] = 1;			
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 10000000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[bodies].alpha =rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];
			spawningVelX = 0;
			spawningVelY = 0;
			
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 1.0;
			rockView[0].alpha = 0.0;
			h20View[0].alpha = 0.0;
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = true;
			break; 
		}// end of level 6 setup
		case 17:
		{
			
			//tempString =[[NSString alloc] initWithCString: "\nPlace the ufo on the X, Be carfull it'll drift"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.03; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = true;
			
			
			killBoxX1 = 0/scale;
			killBoxY1 = 240/scale;
			killBoxX2 = 200/scale;
			killBoxY2 = 300/scale;
			killBoxView.frame = CGRectMake(killBoxX1, killBoxY1,killBoxX1-killBoxX2,killBoxY1-killBoxY2);	
						[self.view addSubview:killBoxView];
			
			
			
			killBoxView = [[UIImageView alloc] initWithImage:killBoxImage];
			killBoxView.alpha = 1.0;	
			
			
			
			
			spawn = true;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			IronProb = 0;
			H20Prob = 0;
			RockProb = 50;
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 10;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 1000000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255
			spawnBomb = false;
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			ufoImage = [UIImage imageNamed:@"ufo_large.png"]; //The curser
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];		
			//Setup Button Views	
			x[bodies] = 1200;			
			y[bodies] = 1200;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[bodies] = 1.0;	
			iron[bodies] = 0.0;
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 20000000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[bodies] = [[UIImageView alloc] initWithImage:magmaImage];			
			
			//BGView = [[UIImageView alloc] initWithImage:BGImage];	
			
			// Set the opacity for each based on material value
			rockView[bodies].alpha =1;//rock[bodies];
			ironView[bodies].alpha =1;
			h20View[bodies].alpha =h20[bodies];
			
			
			rock[0] = 1;
			iron[0] = 0;
			h20[0] = 0;
			
			ironView[0].alpha = 1.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 1.0;
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			break;
		}// end of level 6 setup
			
			
		case 18:
		{
			
			//tempString =[[NSString alloc] initWithCString: "\nPlace the ufo on the X, Be carfull it'll drift"];
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.03; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = true;
			
			killBoxX1 = 0/scale;
			killBoxY1 = 240/scale;
			killBoxX2 = 200/scale;
			killBoxY2 = 300/scale;
			killBoxView.frame = CGRectMake(killBoxX1, killBoxY1,killBoxX1-killBoxX2,killBoxY1-killBoxY2);	
						[self.view addSubview:killBoxView];
			
			
			
			killBoxView = [[UIImageView alloc] initWithImage:killBoxImage];
			killBoxView.alpha = 1.0;	
			
			
			
			
			spawn = true;
			spawnX = 0;//(swidth/scale)/2;
			spawnY = (400/scale);  //Where is the spawn point, where will the rock be created
			spawningVelX = 10;
			IronProb = 0;
			H20Prob = 100;
			RockProb = 0;
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 10;
			spawnedVelY = 0; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 2000000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255
			spawnBomb = false;
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			ufoImage = [UIImage imageNamed:@"ufo_large.png"]; //The curser
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views	
			x[bodies] = 1200;			
			y[bodies] = 1200;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[bodies] = 0.0;	
			iron[bodies] = 0.0;
			h20[bodies] = 1.0;
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 20000000;
			r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:magmaImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:earthlikeImage];
			rockView[bodies] = [[UIImageView alloc] initWithImage:magmaImage];			
			
			BGView = [[UIImageView alloc] initWithImage:BGImage];	
			
			// Set the opacity for each based on material value
			rockView[bodies].alpha =1;//rock[bodies];
			ironView[bodies].alpha =0;
			h20View[bodies].alpha =0;
			bombsEnabled = false;
			zerosEnabled = true;
			blackHolesEnabled = false;
			break;
		}// end of level 6 setup
		case 19:
		{
			noAppliesGrow = false;
			curserCanMove = false;			
			//newString = [newString stringByAppendingString:tempString];	
			scale =0.3; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			spawn = false;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 5; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 1000000;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.05 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 300; // Gravitational Constant
			bodies = 4; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			applyPhysics[0] = false;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			ufoImage = [UIImage imageNamed:@"ufo_large.png"]; //The curser
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			
			rock[0] = 0;
			iron[0] = 1;
			h20[0] = 0;
			
			ironView[0].alpha = 0.0;
			rockView[0].alpha = 1.0;
			h20View[0].alpha = 0.0;
			
			//Setup Button Views			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			//Dont fuck with 1 it's in orbit
			x[1] = (swidth/3)/scale;			
			y[1] = (sheight/3)+2/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			h20[1] = 1.0;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = -3; //No Velocity initanly
			vely[1] = 1;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:ufoImage];
			h20View[1] = [[UIImageView alloc] initWithImage:ufoImage];
			rockView[1] = [[UIImageView alloc] initWithImage:ufoImage];
			applyPhysics[1] = false;
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];	
			
			x[2] = (swidth/scale)/4;			
			y[2] = (sheight/scale)/4;
			velx[2] = -.5;
			vely[2] = .5;
			rock[2] = h20[2] = iron[2] = 0; //Instanciate matierial values
			applyPhysics[2] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[2] = 0.3;
			h20[2] = 0.3;
			iron[2] = 0.4;			
			bomb[2] = false; //Shouldn't explode TODO random explosives for demo			
			mass[2] = 1000000;
			r[2] = sqrt(mass[2]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[2] = [[UIImageView alloc] initWithImage:ufoImage];
			h20View[2] = [[UIImageView alloc] initWithImage:ufoImage];
			rockView[2] = [[UIImageView alloc] initWithImage:ufoImage];
			// Set the opacity for each based on material value
			rockView[2].alpha =rock[2];
			ironView[2].alpha =iron[2];
			h20View[2].alpha =h20[2];
			bombsEnabled = false;
			zerosEnabled = false;
			blackHolesEnabled = false;
			
			
			
			/*x[bodies] = 100;			
			y[bodies] = 100;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[bodies] = 0.3;
			h20[bodies] = 0.3;
			iron[bodies] = 0.4;			
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 10000;
			r[bodies] = 1000;//sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:ufoImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:ufoImage];
			rockView[bodies] = [[UIImageView alloc] initWithImage:ufoImage];
			// Set the opacity for each based on material value
			rockView[bodies].alpha =rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];*/
			
			
			x[3] = (swidth/scale)*3;				
			y[3] = (sheight/scale)*3;
			rock[3] = h20[3] = iron[3] = 0; //Instanciate matierial values
			applyPhysics[3] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[3] = 1.0;
			h20[3] = 0.0;
			iron[3] = 0.0;			
			bomb[3] = false; //Shouldn't explode TODO random explosives for demo
			velx[3] = 0; //No Velocity initanly
			vely[3] = 0;			
			mass[3] = 10000/2;
			r[bodies] = 1000;//sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[3] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[3] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[3] = [[UIImageView alloc] initWithImage:smallRockImage];	
			// Set the opacity for each based on material value
			rockView[3].alpha =rock[3];
			ironView[3].alpha =iron[3];
			h20View[3].alpha =h20[3];
			
			
			
			x[bodies] = (swidth/scale)*2;				
			y[bodies] = (sheight/scale)*2;
			rock[bodies] = h20[bodies] = iron[bodies] = 0; //Instanciate matierial values
			applyPhysics[bodies] = false; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			rock[bodies] = 0.0;
			h20[bodies] = 1.0;
			iron[bodies] = 0.0;			
			bomb[bodies] = false; //Shouldn't explode TODO random explosives for demo
			velx[bodies] = 0; //No Velocity initanly
			vely[bodies] = 0;			
			mass[bodies] = 10000;
			r[bodies] = 1000;//sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[bodies] = [[UIImageView alloc] initWithImage:magmaImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:earthlikeImage];
			rockView[bodies] = [[UIImageView alloc] initWithImage:magmaImage];	
			// Set the opacity for each based on material value
			rockView[bodies].alpha =rock[bodies];
			ironView[bodies].alpha =iron[bodies];
			h20View[bodies].alpha =h20[bodies];
			killOnExit = false;
			
			break;
		}// end of level 6 setup			
		/*case 18:
		{
			//newString = [newString stringByAppendingString:tempString];	
			scale = 0.03; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			spawn = false;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.05 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 100; // Gravitational Constant
			bodies = 1; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = 300/scale;			
			y[1] = 20/scale;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			applyPhysics[1] = true; //These objects should be effected by physics
			//Randomly make it rock, Ice or Iron			
			h20[1] = 1.0;			
			bomb[1] = false; //Shouldn't explode TODO random explosives for demo
			velx[1] = 0; //No Velocity initanly
			vely[1] = 0;			
			mass[1] = 1000000;
			r[1] = sqrt(mass[1]); //Make the radius sq root of mass, Shutup! It's cartoony				
			// Setup 3 views for each body
			ironView[1] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[1] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[1] = [[UIImageView alloc] initWithImage:smallRockImage];
			// Set the opacity for each based on material value
			rockView[1].alpha =rock[1];
			ironView[1].alpha =iron[1];
			h20View[1].alpha =h20[1];
			break;
		}// end of level 6 setup			
		case 19:
		{
			scale = 0.03; // Zoomscale
			pauseAfterLoop = true;
			killBoxExists = false;
			spawn = true;
			spawnX = (swidth/scale)/2;
			spawnY = (sheight/scale);  //Where is the spawn point, where will the rock be created
			//spawningVelX = 10;
			//spawningVelY =10; //what is the velocity of the spawning point
			spawnedVelX = 0;
			spawnedVelY = -10; //WHat is the velocity of the rock COMING FROM the spawning point;
			spawnTime = 3; //How often do you want a rock to be produced
			spawnTimeLeft =0;
			spawnedMass = 100000;
			//int H20Prob, RockProb, IronProb; //Should add upto 255			
			// Margin at the edge, how far can a body go off screen before it's brought back in			
			margin = 10;			
			paused = false;// Not paused
			// BG Colour 0.0 to 1.0
			self.view.backgroundColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.05 alpha:1.0];
			t=.5; // Gravity time, esentaly game speed			
			grav = 100; // Gravitational Constant
			bodies = 25; //Number of bodies
			noEffectR = 600; // Radius around the UFO where bodies are uneffected by it's feild
			//Place the UFO at the center of the screen
			x[0] = (swidth/scale)/2;
			y[0] = (sheight/scale)/2;			
			//Instansiating is just good practice
			velx[0] = 0;
			vely[0] = 0;
			//How heavy is our UFO
			mass[0] = 1000000;
			killOnExit = true;
			// The size of our UFO
			r[0] = 1000;
			//Setup the UFO View with UFO image
			rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
			//Setup Button Views			
			//Setup a number (bodies) of randomly placed and weighted bodies (Asteriods,comets;Symantics)
			x[1] = 120/scale;			
			y[1] = 20/scale;
			mass[1] = 1;
			r[1] = 30/scale;
			applyPhysics[1] = false;
			rock[1] = h20[1] = iron[1] = 0; //Instanciate matierial values
			
			x[2] = 80/scale;			
			y[2] = 50/scale;
			mass[2] = 1;
			r[2] = 30/scale;
			applyPhysics[2] = false;
			rock[2] = h20[2] = iron[2] = 0; //Instanciate matierial values
			
			x[3] = 50/scale;			
			y[3] = 90/scale;
			mass[3] = 1;
			r[3] = 30/scale;
			applyPhysics[3] = false;
			rock[3] = h20[3] = iron[3] = 0; //Instanciate matierial values
			
			x[4] = 10/scale;			
			y[4] = 130/scale;
			mass[4] = 1;
			r[4] = 30/scale;
			applyPhysics[4] = false;
			rock[4] = h20[4] = iron[4] = 0; //Instanciate matierial values
			
			x[5] = 10/scale;			
			y[5] = 180/scale;
			mass[5] = 1;
			r[5] = 30/scale;
			applyPhysics[5] = false;
			rock[5] = h20[5] = iron[5] = 0; //Instanciate matierial values
			
			x[6] = 20/scale;			
			y[6] = 220/scale;
			mass[6] = 1;
			r[6] = 30/scale;
			applyPhysics[6] = false;
			rock[6] = h20[6] = iron[6] = 0; //Instanciate matierial values
			
			x[7] = 40/scale;			
			y[7] = 260/scale;
			mass[7] = 1;
			r[7] = 30/scale;
			applyPhysics[7] = false;
			rock[7] = h20[7] = iron[7] = 0; //Instanciate matierial values
			
			x[8] = 100/scale;			
			y[8] = 300/scale;
			mass[8] = 1;
			r[8] = 30/scale;
			applyPhysics[8] = false;
			rock[8] = h20[8] = iron[8] = 0; //Instanciate matierial values
			
			x[9] = 110/scale;			
			y[9] = 330/scale;
			mass[9] = 1;
			r[9] = 30/scale;
			applyPhysics[9] = false;
			rock[9] = h20[9] = iron[9] = 0; //Instanciate matierial values
			
			x[10] = 110/scale;			
			y[10] = 390/scale;
			mass[10] = 1;
			r[10] = 30/scale;
			applyPhysics[10] = false;
			rock[10] = h20[10] = iron[10] = 0; //Instanciate matierial values
			
			x[11] = 110/scale;			
			y[11] = 430/scale;
			mass[bodies] = 1;
			r[11] = 30/scale;
			applyPhysics[11] = false;
			rock[11] = h20[11] = iron[11] = 0; //Instanciate matierial values
			
			x[12] = 230/scale;			
			y[12] = 430/scale;
			mass[12] = 1;
			r[12] = 30/scale;
			applyPhysics[12] = false;
			rock[12] = h20[12] = iron[12] = 0; //Instanciate matierial values
			
			x[13] = 230/scale;			
			y[13] = 390/scale;
			mass[13] = 1;
			r[13] = 30/scale;
			applyPhysics[13] = false;
			rock[13] = h20[13] = iron[13] = 0; //Instanciate matierial values
			
			x[14] = 230/scale;			
			y[14] = 330/scale;
			mass[14] = 1;
			r[14] = 30/scale;
			applyPhysics[14] = false;
			rock[14] = h20[14] = iron[14] = 0; //Instanciate matierial values
			
			
			
			x[15] = 300/scale;			
			y[15] = 200/scale;
			mass[15] = 1;
			r[15] = 30/scale;
			applyPhysics[15] = false;
			rock[15] = h20[15] = iron[15] = 0; //Instanciate matierial values
			
			x[16] = 300/scale;			
			y[16] = 260/scale;
			mass[16] = 1;
			r[16] = 30/scale;
			applyPhysics[16] = false;
			rock[16] = h20[16] = iron[16] = 0; //Instanciate matierial values
			
			x[17] = 300/scale;			
			y[17] = 300/scale;
			mass[17] = 1;
			r[17] = 30/scale;
			applyPhysics[17] = false;
			rock[17] = h20[17] = iron[17] = 0; //Instanciate matierial values
			
			x[18] = 300/scale;			
			y[18] = 180/scale;
			mass[18] = 1;
			r[18] = 30/scale;
			applyPhysics[18] = false;
			rock[18] = h20[18] = iron[18] = 0; //Instanciate matierial values
			
			x[19] = 300/scale;			
			y[19] = 130/scale;
			mass[19] = 1;
			r[19] = 30/scale;
			applyPhysics[19] = false;
			rock[19] = h20[19] = iron[19] = 0; //Instanciate matierial values
			
			x[20] = 300/scale;			
			y[20] = 90/scale;
			mass[20] = 1;
			r[20] = 30/scale;
			applyPhysics[20] = false;
			rock[20] = h20[20] = iron[20] = 0; //Instanciate matierial values
			
			x[21] = 290/scale;			
			y[21] = 50/scale;
			mass[21] = 1;
			r[21] = 30/scale;
			applyPhysics[21] = false;
			rock[21] = h20[21] = iron[21] = 0; //Instanciate matierial values
			
			x[22] = 250/scale;			
			y[22] = 20/scale;
			mass[22] = 1;
			r[22] = 30/scale;
			applyPhysics[22] = false;
			rock[22] = h20[22] = iron[22] = 0; //Instanciate matierial values
			
			x[23] = 140/scale;			
			y[23] = 170/scale;
			mass[23] = 1;
			r[23] = 30/scale;
			applyPhysics[23] = false;
			rock[23] = h20[23] = iron[23] = 0; //Instanciate matierial values
			
			x[24] = 200/scale;			
			y[24] = 170/scale;
			mass[24] = 1;
			r[24] = 30/scale;
			applyPhysics[24] = false;
			rock[24] = h20[24] = iron[24] = 0; //Instanciate matierial values
			
			x[25] = 170/scale;			
			y[25] = 200/scale;
			mass[25] = 1;
			r[25] = 30/scale;
			applyPhysics[25] = false;
			rock[25] = h20[25] = iron[25] = 0; //Instanciate matierial values
			
			//These objects should be effected by physics
			//Randomly make it rock, Ice or Iron
			for(int i = 1;i<=bodies;i++)
			{
				rock[0] = 1;
				iron[0] = 0;
				h20[0] = 0;
				
				bomb[i] = false; //Shouldn't explode TODO random explosives for demo
				velx[i] = 0; //No Velocity initanly
				vely[i] = 0;
				
				mass[i] = 1;
				
				//r[bodies] = sqrt(mass[bodies]); //Make the radius sq root of mass, Shutup! It's cartoony				
				// Setup 3 views for each body
				ironView[i] = [[UIImageView alloc] initWithImage:smallIronImage];
				h20View[i] = [[UIImageView alloc] initWithImage:smallH20Image];
				rockView[i] = [[UIImageView alloc] initWithImage:smallRockImage];
				// Set the opacity for each based on material value
				rockView[i].alpha =rock[i];
				ironView[i].alpha =iron[i];
				h20View[i].alpha =h20[i];
			}
			noAppliesGrow =false;
			break;
		} // End of level 7 setup	
			*/
	}// End of Case
	
	if(loadFromState)
	{
		[self LoadState];
		loadFromState = false;
	}
	
//[self LoadScores:level];
	loading = false;
	
	
	
	
	//********** Finish UP ********************************
	
	
	//NSString *newString =[[NSString alloc] initWithCString: "Level "];
	//NSString *tempString;						
	//tempString = [NSString stringWithFormat:@"%i", level];	
	//newString = [newString stringByAppendingString:tempString];	
	
	
	//debugText.text = newString;	
} // End Method

//- (void)MakeBlackHole:(double)bx :(double)by;
- (int) placeScore:(int)mscore :(int)mlevel 
{
	//NSLog(@"Started placescore score:%i level:%i",mscore,mlevel);
	bool moveDown = false;
	int placeAt = -1;
	for(int i = (mlevel*10);i<((mlevel*10)+10);i++)
	{
		//NSLog(@"i = %i",i);
		if(mscore>scores[i])
		{
			//NSLog(@"at [%i], mscore:%i  >  scores[i]:%i ",i,mscore,scores[i]);
			moveDown = true;
			placeAt = i;
			break;
		}		
	}	
	if(moveDown)
	{
	for(int i = ((mlevel*10)+9);i>placeAt;i--)
	{
		//NSLog(@"at [%i] moving scores[i+1]:%i  >  scores[i]:%i ",i,scores[i+1],scores[i]);
		scores[i] = scores[i-1];
	}
		scores[placeAt] = mscore;
	}
	return 0;
}





/**************************************************************************************************************
 Saving/Loading Stuff
 *************************************************************************************************************/
- (NSString *) optionsFilePath
{	
	
	//Dont using new string add to existing string and send to lable, do not clear.
	//NSString *tempString;	
	/////
	//NSLog(@"options file path");
	NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
	//NSLog(@"2");
	NSString *documentsDirectory = [paths objectAtIndex:0];
	//NSLog(@"3");
	
	//tempString =[[NSString alloc] initWithCString: "\nSetting up path\n"];
	//newString = [newString stringByAppendingString:tempString];	
	
	//tempString =[[NSString alloc] initWithCString: documentsDirectory];
	//newString = [newString stringByAppendingString:documentsDirectory];	
	
	//NSLog(@"4");
	NSString *tempPath = [[NSString alloc] initWithCString: "options.plist"];
	//NSLog(@"5");
	//[paths release];
	return [documentsDirectory stringByAppendingPathComponent:tempPath];	
	
	//return documentsDirectory;
	
}


- (NSString *) dataFilePath
{	
	
	//Dont using new string add to existing string and send to lable, do not clear.
	//NSString *tempString;	
	/////
	
	NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
	NSString *documentsDirectory = [paths objectAtIndex:0];
	
	//tempString =[[NSString alloc] initWithCString: "\nSetting up path\n"];
	//newString = [newString stringByAppendingString:tempString];	
	
	//tempString =[[NSString alloc] initWithCString: documentsDirectory];
	//newString = [newString stringByAppendingString:documentsDirectory];	
	
	
	NSString *tempPath = [[NSString alloc] initWithCString: "state.plist"];
	return [documentsDirectory stringByAppendingPathComponent:tempPath];	
	
	//return documentsDirectory;
	
}

- (NSString *) scoreFilePath
{	
	
	//Dont using new string add to existing string and send to lable, do not clear.
	//NSString *tempString;	
	/////
	//NSLog(@"score file path 1");
	NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
	//NSLog(@"2");
	NSString *documentsDirectory = [paths objectAtIndex:0];
	//NSLog(@"3");
	//tempString =[[NSString alloc] initWithCString: "\nSetting up path\n"];
	//newString = [newString stringByAppendingString:tempString];	
	
	//tempString =[[NSString alloc] initWithCString: documentsDirectory];
	//newString = [newString stringByAppendingString:documentsDirectory];	
	
	//NSLog(@"4");
	NSString *tempPath = [[NSString alloc] initWithCString: "scores.plist"];
	//NSLog(@"5");
	//[tempPath release];
	//[documentsDirectory release];
	return [documentsDirectory stringByAppendingPathComponent:tempPath];	
	
	
	
	//return documentsDirectory;
	
}

-(int)LoadState
{
	
	/////
	/*
	 NSString *filePath = [self dataFilePath];
	 if ([[NSFileManager defaultManager] fileExistsAtPath:filePath])
	 {
	 NSMutableArray *array = [[NSMutableArray alloc] initWithContentsOfFile:filePath];
	 field1.text = filePath;
	 field2.text = [array objectAtIndex:1];
	 field3.text = [array objectAtIndex:2];
	 field4.text = [array objectAtIndex:3];
	 [array release];
	 }
	 */
	
	/////
	
	

	
	
	
	
	//tempString =[[NSString alloc] initWithCString: "\nLoading State From => "];
	//newString = [newString stringByAppendingString:tempString];
	
	NSString *path = [self dataFilePath];
	
	
	//tempString =[[NSString alloc] initWithCString:path];
	//newString = [newString stringByAppendingString:tempString];	
	
	//path = [path stringByAppendingString:kFilename];
	
	
	//NSLog(@"Loading State:");	
	@try
	{
		if([[NSFileManager defaultManager] fileExistsAtPath:path])
		{
			
			
			
			//NSLog(@"File Existing Continueing");
			
			
			while(bodies >=1)
			{
				// Bug Warning
				//The body above 1 will be movied down to 1 each time
				//NSLog(@"Destoryed cause clearing");
				[self destroyBody: 1];
			}
			//tempString =[[NSString alloc] initWithCString: "\nMade it into IF w/path =>"];
			//newString = [newString stringByAppendingString:tempString];
			
			//newString = [newString stringByAppendingString:path];	
			//NSNumber *myNo;
			NSMutableArray *array = [[NSArray alloc] initWithContentsOfFile:path];
			
			
			//tempString = [NSString stringWithFormat:@"%i", [array count]];	
			//newString = [newString stringByAppendingString:tempString];				
			//NSLog(@"count = %i", [array count]);
			NSNumber *numx;			
			if(([array count]%14)!=0)
			{
				return -1;
			}
			bodies = [array count]/14;
			//NSLog(@"bodies = %i", bodies);			//bodies = array size
			for(int i = 0; i <bodies;i++)
			{
				//NSLog(@"i = %i", i);
				//tempString = [NSString stringWithFormat:@"%i",i];	
				//newString = [newString stringByAppendingString:tempString];	
				numx = [array objectAtIndex:i];
				x[i] = [numx doubleValue];
				
				
				
				numx = [array objectAtIndex:i+bodies];
				y[i] = [numx doubleValue];
				
				
				numx = [array objectAtIndex:i+(bodies*2)];
				velx[i] = [numx doubleValue];	
				
				
				numx = [array objectAtIndex:i+(bodies*3)];
				vely[i] = [numx doubleValue];	
				
				
				numx = [array objectAtIndex:i+(bodies*4)];
				r[i] = [numx doubleValue];	
				
				
				numx = [array objectAtIndex:i+(bodies*5)];
				mass[i] = [numx doubleValue];	
				
				
				numx = [array objectAtIndex:i+(bodies*6)];
				TTL[i] = [numx doubleValue];	
				
				
				numx = [array objectAtIndex:i+(bodies*7)];
				iron[i] = [numx doubleValue];	
				
				
				numx = [array objectAtIndex:i+(bodies*8)];
				h20[i] = [numx doubleValue];	
				
				
				numx = [array objectAtIndex:i+(bodies*9)];
				rock[i] = [numx doubleValue];	
				
				
				numx = [array objectAtIndex:i+(bodies*10)];
				noJoinTime[i] = [numx doubleValue];	
				
				
				numx = [array objectAtIndex:i+bodies*11];
				hasTTL[i] = [numx boolValue];	
				
				
				numx = [array objectAtIndex:i+bodies*12];
				bomb[i] = [numx boolValue];	
				
				
				numx = [array objectAtIndex:i+bodies*13];
				applyPhysics[i] = [numx boolValue];	
				
				
				//tempString = [NSString stringWithFormat:@"%i",x[i]];	
				//newString = [newString stringByAppendingString:tempString];	
				
				//mass[i] = 500;
				
				
				//NSLog(@"loaded Point (%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%i,%i,%i)",x[i],y[i],velx[i],vely[i],r[i],mass[i],TTL[i],iron[i],h20[i],rock[i],noJoinTime[i],hasTTL[i],bomb[i],applyPhysics[i]);
				//y[i] = (int)[array objectAtIndex:i+bodies];
			}
			//bodies--; // BUGFIX TODO: understand, probable off by one in load/save process
			//tempString =[[NSString alloc] initWithCString: "\nRealeasing"];
			//newString = [newString stringByAppendingString:tempString];
			//NSLog(@"Trying to release array");
			//[array malloc];
			//NSLog(@"Trying to release");
			[array release];
			//NSLog(@"Success");
		}
	}
	@catch (NSException *exception) {
		//NSLog(@"This aint good %@: %@",[exception name],[exception reason]);
		//NSString *tempString =[[NSString alloc] initWithCString: "\nLoad failed"];
		//newString = [newString stringByAppendingString:tempString];	
		
	}
	@finally
	{
	}
	//NSLog(@"Initalising Rocks");
	for(int i = 1; i< bodies; i++)
	{//NSLog(@"I:%i",i);
		if(bomb[i] == true)
		{
			//NSLog(@"In Bomb");
			ironView[i] = [[UIImageView alloc] initWithImage:bombImage];
			h20View[i] = [[UIImageView alloc] initWithImage:bombImage];
			rockView[i] = [[UIImageView alloc] initWithImage:bombImage];
		}
		else{
			//NSLog(@"In NotBomb");
		ironView[i] = [[UIImageView alloc] initWithImage:smallIronImage];
		h20View[i] = [[UIImageView alloc] initWithImage:smallH20Image];
		rockView[i] = [[UIImageView alloc] initWithImage:smallRockImage];
		}
		// Set the opacity for each based on material value
		rockView[i].alpha =rock[i];
		ironView[i].alpha =iron[i];
		h20View[i].alpha =h20[i];
	}
	//debugText.text = newString;	
	rockView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
	ironView[0] = [[UIImageView alloc] initWithImage:ufoImage];	
	h20View[0] = [[UIImageView alloc] initWithImage:ufoImage];	
	/*for(int i = 0; i< bodies;i++)
	{

	}
	*/

	//NSLog(@"Done, Returing");
	//[path release];
	return 0;
}





-(int)LoadOptions
{
	
		//NSLog(@"Loading Optiond:");	
	NSString *path = [self optionsFilePath];
	
	
	//tempString =[[NSString alloc] initWithCString:path];
	//newString = [newString stringByAppendingString:tempString];	
	
	//path = [path stringByAppendingString:kFilename];
	
	

	@try
	{
		if([[NSFileManager defaultManager] fileExistsAtPath:path])
		{
			//NSLog(@"File Existing Continueing");
			//tempString =[[NSString alloc] initWithCString: "\nMade it into IF w/path =>"];
			//newString = [newString stringByAppendingString:tempString];
			
			//newString = [newString stringByAppendingString:path];	
			//NSNumber *myNo;
			NSMutableArray *array = [[NSArray alloc] initWithContentsOfFile:path];
			
			
			//tempString = [NSString stringWithFormat:@"%i", [array count]];	
			//newString = [newString stringByAppendingString:tempString];				
			//NSLog(@"count = %i", [array count]);
			
			NSNumber *numx;			
			//LEVEL
			numx = [array objectAtIndex:0];
			level = [numx intValue];
			//NSLog(@"loaded Level no (%i)",level);
			//TIME
			numx = [array objectAtIndex:1];
			game_time= [numx doubleValue];
			//NSLog(@"loaded time (%d)",game_time);
			
			//SCORE
			numx = [array objectAtIndex:2];
			score = [numx intValue];		
			
			//NSLog(@"score (%i)",score);
			//y[i] = (int)[array objectAtIndex:i+bodies];
			
			//tempString =[[NSString alloc] initWithCString: "\nRealeasing"];
			//newString = [newString stringByAppendingString:tempString];
			
			
			
			/*if ([path length]>0)
			{
				[path release];
			}*/
			
			
			
			[array release];
		}
		
		
	}
	@catch (NSException *exception) {
		//NSLog(@"This aint good %@: %@",[exception name],[exception reason]);
		//NSString *tempString =[[NSString alloc] initWithCString: "\nLoad failed"];
		//newString = [newString stringByAppendingString:tempString];	
		
	}
	@finally
	{
	}

		return 0;
	
}

-(int)SaveOptions
{
	//NSLog(@"Saving Options:");
	NSString *path = [self optionsFilePath];
		NSString *tmpPath = [path stringByAppendingString:@".tmp"];
	//path = [path stringByAppendingString:kFilename];
	//NSLog(@"decraring number");
	NSNumber *myNo;
	//NSLog(@"declaring array");
	NSMutableArray *array = [[NSMutableArray alloc] init];
	
	
	//NSLog(@"array size:%i",[array count]);	
	
	//LEVEL NUMBER
	//NSLog(@"setting up number");
	//NSLog(@"saving Level no (%i)",level);
	myNo = [NSNumber numberWithInt:level];
	//tempString = [NSString stringWithFormat:@"%i",x[i]];	
	//newString = [newString stringByAppendingString:tempString];	
	//[array addObject:myNo];
	//NSLog(@"inserting object");
	[array insertObject:myNo atIndex:0];
	
	
	//TIME
	//NSLog(@"setting up number");
	//NSLog(@"saving time (%d)",game_time);
	myNo = [NSNumber numberWithDouble:game_time];
	//tempString = [NSString stringWithFormat:@"%i",x[i]];	
	//newString = [newString stringByAppendingString:tempString];	
	//[array addObject:myNo];
	//NSLog(@"inserting object");
	[array insertObject:myNo atIndex:1];
	
	
	//Score
	//NSLog(@"setting up number");
	//NSLog(@"score (%i)",score);
	myNo = [NSNumber numberWithInt:score];
	//tempString = [NSString stringWithFormat:@"%i",x[i]];	
	//newString = [newString stringByAppendingString:tempString];	
	//[array addObject:myNo];
	//NSLog(@"inserting object");
	[array insertObject:myNo atIndex:2];
	
	
	
	
	
	
	
	
	//NSLog(@"bodies:%i",bodies);
	//NSLog(@"array size:%i",[array count]);
	
	//NSString *tempString =[[NSString alloc] initWithCString: "\nSaving State"];
	//newString = [newString stringByAppendingString:tempString];		
	//debugText.text = newString;	
	//NSLog(@"writing...");
	[array writeToFile:tmpPath atomically:YES];
	[array release];
	

	if(level!=0||level!=19)
	{
			[[NSFileManager defaultManager] removeItemAtPath:path  error:nil];
	[[NSFileManager defaultManager] moveItemAtPath:tmpPath toPath:path error:nil];
	}
	[path release];
	return 0;
}



-(int)SaveState
{
	//NSLog(@"Saving State:");
	NSString *path = [self dataFilePath];
	NSString *tmpPath = [path stringByAppendingString:@".tmp"];
	//NSLog(@"decraring number");
	NSNumber *myNo;
	//NSLog(@"declaring array");
	NSMutableArray *array = [[NSMutableArray alloc] init];
	
	
	//NSLog(@"array size:%i",[array count]);	
	
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F1 i = %i",i);
		myNo = [NSNumber numberWithDouble:x[i]];
		//tempString = [NSString stringWithFormat:@"%i",x[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		//[array addObject:myNo];
		//NSLog(@"inserting object");
		[array insertObject:myNo atIndex:i];
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F2 i = %i",i);
		myNo = [NSNumber numberWithDouble:y[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f)",x[i],y[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F3 i = %i",i);
		myNo = [NSNumber numberWithDouble:velx[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f)",x[i],y[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F4 i = %i",i);
		myNo = [NSNumber numberWithDouble:vely[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f)",x[i],y[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F5 i = %i",i);
		myNo = [NSNumber numberWithDouble:r[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f)",x[i],y[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F6 i = %i",i);
		myNo = [NSNumber numberWithDouble:mass[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f)",x[i],y[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F7 i = %i",i);
		myNo = [NSNumber numberWithDouble:TTL[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f)",x[i],y[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F8 i = %i",i);
		myNo = [NSNumber numberWithDouble:iron[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f)",x[i],y[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F9 i = %i",i);
		myNo = [NSNumber numberWithDouble:h20[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f)",x[i],y[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F10 i = %i",i);
		myNo = [NSNumber numberWithDouble:rock[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f)",x[i],y[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F11 i = %i",i);
		myNo = [NSNumber numberWithDouble:noJoinTime[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f)",x[i],y[i],velx[i],vely[i],r[i],mass[i],TTL[i],iron[i],h20[i],rock[i],noJoinTime[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F12 i = %i",i);
		myNo = [NSNumber numberWithBool:hasTTL[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f)",x[i],y[i],velx[i],vely[i],r[i],mass[i],TTL[i],iron[i],h20[i],rock[i],noJoinTime[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F13 i = %i",i);
		myNo = [NSNumber numberWithBool:bomb[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f)",x[i],y[i],velx[i],vely[i],r[i],mass[i],TTL[i],iron[i],h20[i],rock[i],noJoinTime[i]);
	}
	for(int i = 0; i <= bodies; i++)
	{
		//NSLog(@"F14 i = %i",i);
		myNo = [NSNumber numberWithBool:applyPhysics[i]];
		//tempString = [NSString stringWithFormat:@"%i",y[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		[array addObject:myNo];
		//[array insertObject:myNo atIndex:i+bodies];		
		//NSLog(@"saved Point (%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%i,%i,%i)",x[i],y[i],velx[i],vely[i],r[i],mass[i],TTL[i],iron[i],h20[i],rock[i],noJoinTime[i],hasTTL[i],bomb[i],applyPhysics[i]);
	}
	/*for(int i = 0; i < bodies; i++)
	 {
	 myNo = [NSNumber numberWithDouble:noJoinTime[i]];
	 tempString = [NSString stringWithFormat:@"%i",y[i]];	
	 newString = [newString stringByAppendingString:tempString];	
	 [array addObject:myNo];
	 //[array insertObject:myNo atIndex:i+bodies];		
	 NSLog(@"saved Point (%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f)",x[i],y[i],velx[i],vely[i],r[i],mass[i],TTL[i],iron[i],h20[i],rock[i],noJoinTime[i]);
	 }*/
	
	
	//NSLog(@"bodies:%i",bodies);
	//NSLog(@"array size:%i",[array count]);
	
	//NSString *tempString =[[NSString alloc] initWithCString: "\nSaving State"];
	//newString = [newString stringByAppendingString:tempString];		
	//debugText.text = newString;	
	
	[array writeToFile:tmpPath atomically:YES];
	[array release];
	

	if(level!=0||level!=0)
	{
			[[NSFileManager defaultManager] removeItemAtPath:path  error:nil];
	[[NSFileManager defaultManager] moveItemAtPath:tmpPath toPath:path error:nil];
	}
	//[[NSFileManager defaultManager] moveItemAtPath:<#(NSString *)srcPath#> toPath:<#(NSString *)dstPath#> error:<#(NSError **)error#>

	
	[path release];
	return 0;
}




-(int)LoadScores:(int) llevel
{
	
	
	/////
	/*
	 NSString *filePath = [self dataFilePath];
	 if ([[NSFileManager defaultManager] fileExistsAtPath:filePath])
	 {
	 NSMutableArray *array = [[NSMutableArray alloc] initWithContentsOfFile:filePath];
	 field1.text = filePath;
	 field2.text = [array objectAtIndex:1];
	 field3.text = [array objectAtIndex:2];
	 field4.text = [array objectAtIndex:3];
	 [array release];
	 }
	 */
	
	/////
	
	//tempString =[[NSString alloc] initWithCString: "\nLoading State From => "];
	//newString = [newString stringByAppendingString:tempString];

	NSString *path = [self scoreFilePath];
	
	
	//tempString =[[NSString alloc] initWithCString:path];
	//newString = [newString stringByAppendingString:tempString];	
	
	//path = [path stringByAppendingString:kFilename];
	
	
	//NSLog(@"Loading Scores:");	
	
	if([[NSFileManager defaultManager] fileExistsAtPath:path])
	{
		//NSLog(@"File Existing Continueing");
		//NSNumber *myNo;
		NSMutableArray *array = [[NSArray alloc] initWithContentsOfFile:path];
		//NSLog(@"count = %i", [array count]);
		NSNumber *numx;			
		bodies = [array count]/14;
		//NSLog(@"bodies = %i", bodies);			//bodies = array size
		for(int i = 0; i <200;i++)
		{
			//NSLog(@"i = %i", i);
			//tempString = [NSString stringWithFormat:@"%i",i];	
			//newString = [newString stringByAppendingString:tempString];
			@try{					
				numx = [array objectAtIndex:i];
				scores[i] = (int)[numx doubleValue];				
			}
			
			@catch (NSException *exception) {
				//NSLog(@"This aint good %@: %@",[exception name],[exception reason]);
				scores[i] = 0;
			}
			@finally {
				
			}
			
			
			//mass[i] = 500;
			
			
			//NSLog(@"loaded Score at %i (%i)",i,scores[i]);
			//y[i] = (int)[array objectAtIndex:i+bodies];
		}
		//bodies--; // BUGFIX TODO: understand, probable off by one in load/save process
		//tempString =[[NSString alloc] initWithCString: "\nRealeasing"];
		//newString = [newString stringByAppendingString:tempString];
		[array release];
	}
	

	//NSString *tempString =[[NSString alloc] initWithCString: "\nLoad failed"];
	//newString = [newString stringByAppendingString:tempString];	
	
	
	//[path release];
	return 0;
	
}



-(int)SaveScores:(int) llevel
{
	//NSLog(@"Saving Scores:");
	NSString *path = [self scoreFilePath];
		NSString *tmpPath = [path stringByAppendingString:@".tmp"];
	//path = [path stringByAppendingString:kFilename];
	//NSLog(@"decraring number");
	NSNumber *myNo;
	//NSLog(@"declaring array");
	NSMutableArray *array = [[NSMutableArray alloc] init];
	
	
	//NSLog(@"array size:%i",[array count]);	
	//for(int j = [array count]-1; j < 100; j++)
		
	for(int i = 0; i < 200; i++)
	{
		//NSLog(@"i = %i",i);
				//NSLog(@"inserting object at %i (%i)",(level*10)+i,scores[i]);
		//scores[i] = i;
		myNo = [NSNumber numberWithDouble:(double)scores[i]];
		//myNo = [NSNumber numberWithDouble:(double)i];
		//tempString = [NSString stringWithFormat:@"%i",x[i]];	
		//newString = [newString stringByAppendingString:tempString];	
		//[array addObject:myNo];
		//NSLog(@"inserting object at %i (%i)",i,scores[i]);
		[array insertObject:myNo atIndex:i];
	}
	
	
	//NSLog(@"array size:%i",[array count]);
	
	//NSString *tempString =[[NSString alloc] initWithCString: "\nSaving State"];
	//newString = [newString stringByAppendingString:tempString];		
	//debugText.text = newString;	
	//NSLog(@"writing");
	[array writeToFile:path atomically:YES];
	//NSLog(@"Releasing");
	[array writeToFile:tmpPath atomically:YES];
	[array release];
	
	[[NSFileManager defaultManager] removeItemAtPath:path  error:nil];
	[[NSFileManager defaultManager] moveItemAtPath:tmpPath toPath:path error:nil];
	[path release];
	return 0;
	
}

// End of Saving/Loading Stuff

- (bool)goalTest
{
	//NSLog(@"Goals");
	
	int oldscore = score;
	bool goalComplete =false;
	switch (level)
	{
		case 1:
		{
			//if((mass[1] >= 1100000)) //&& (mass[2] >= 1100000))
			//	goalComplete = true;
			break;
		}
		case 2:
		{
			if(mass[1] >= 1500000)
				goalComplete = true;
			
			//score = game_time;
			score = mass[1]-1000000-game_time;
			//tempString = [NSString stringWithFormat:@"%i",score];	
			//tempString = [NSString stringWithFormat:@"Score\n%i",score];	
			//newString = [newString stringByAppendingString:tempString];	
			//debugText.text = tempString;
			break;
		}
		case 3:
		{
			score = (mass[1]*1.1)-(1000000+100000)-game_time;
			if(mass[1] >= 2000000)
				goalComplete = true;
			break;
		}
		case 4:
		{
			score = ((mass[1]*1.1*iron[1])-(1000000+100000)-game_time)-(mass[1]*(h20[1]+rock[1]));
			if(mass[1] >= 2000000)
				goalComplete = true;
			break;
		}
		/*case 4:
		{
			score = (mass[1]*rock[1])-1000000-game_time;;
			if(mass[1] >= 1500000)
			{
				goalComplete = true;
			}
			break;
		}*/
		case 5:
		{
			score = ((((mass[1]*h20[1])     -(mass[1]*(iron[1]+rock[1]))          )+((mass[2]*iron[2]))-game_time)       -(mass[2]*(h20[2]+rock[2]))          )-2000000;
			if(mass[1] >= 2000000 && mass[2] >= 2000000)
			{
				goalComplete = true;
			}
			break;
		}
		case 6:
		{
			score = ((((mass[1]*rock[1])     -(mass[1]*(h20[1]+iron[1]))          )+((mass[2]*h20[2]))-game_time)       -(mass[2]*(iron[2]+rock[2]))          )-1000000;
			if(mass[1] >= 2000000 && mass[2] >= 2000000)
			{
				goalComplete = true;
			}
			break;
		}
		case 7:
		{
			score = ((((mass[1]*rock[1])     -(mass[1]*(iron[1]+h20[1]))          )+((mass[2]*iron[2]))-game_time)       -(mass[2]*(h20[2]+rock[2]))          )-2000000;
			if(mass[1] >= 2000000 && mass[2] >= 2000000)
			{
				goalComplete = true;
			}
			break;
		}
		case 8:
		{
			//score = 0;
			if(game_time > 2*60)
			{
				goalComplete = true;
			}
			if((game_time - old_time)>=1)
			{
			debugText.text =[NSString stringWithFormat:@"Score:%i\nTime:%i\n",score,(2*60)-(int)game_time];
				old_time = game_time;
			}
			
			break;
		}
		case 9:
		{
			//score = 0;
			if(game_time > 2*60)
			{
				goalComplete = true;
			}
			if((game_time - old_time)>=1)
			{
				debugText.text =[NSString stringWithFormat:@"Score:%i\nTime:%i\n",score,(2*60)-(int)game_time];
				old_time = game_time;
			}
			break;
		}
		case 10:
		{
			//score = 0;
			if(game_time > 2*60)
			{
				goalComplete = true;
			}
			if((game_time - old_time)>=1)
			{
				debugText.text =[NSString stringWithFormat:@"Score:%i\nTime:%i\n",score,(2*60)-(int)game_time];
				old_time = game_time;
			}
			break;
		}
		case 11:
		{
			if(mass[1] >= 1500000)
				goalComplete = true;
			
			//score = game_time;
			score =((int)mass[1]-(int)game_time)-1000000;
			//score = 1337;
			break;
		}
		case 12:
		{
			if(mass[1] >= 1500000)
				goalComplete = true;
			
			//score = game_time;
			score = ((mass[1]*1.1*iron[1])-(1000000+100000)-game_time)-(mass[1]*(h20[1]+rock[1]));
			//score = 1337;
			break;
		}
		case 13:
		{
			if(mass[1] >= 1500000)
				goalComplete = true;
			
			//score = game_time;
			score = ((mass[1]*1.1*h20[1])-(1100000)-game_time)-(mass[1]*(iron[1]+rock[1]));
			//score = 1337;
			break;
		}
		case 14:
		{
			score = ((mass[2]*iron[2])-(mass[2]*(h20[2]+rock[2])))+((mass[1]*h20[1])-(mass[1]*(iron[1]+rock[1]))) - 2000000;
			if(mass[3] <= 0.0)
			{
				goalComplete = true;
			}
			break;
		}
		case 15:
		{
			if(mass[1] >= 15000000)
				goalComplete = true;
			
			//score = game_time;
			score = mass[1]-10000000-game_time;
			//tempString = [NSString stringWithFormat:@"%i",score];	
			//tempString = [NSString stringWithFormat:@"Score\n%i",score];	
			//newString = [newString stringByAppendingString:tempString];	
			//debugText.text = tempString;
			break;
		}
		case 16:
		{		
			if(mass[2] >= 15000000)
				goalComplete = true;
			
			//score = game_time;
			score = (mass[1]-10000000)-game_time;
			//score = 1337;
			//tempString = [NSString stringWithFormat:@"%i",score];	
			//tempString = [NSString stringWithFormat:@"Score\n%i",score];	
			//newString = [newString stringByAppendingString:tempString];	
			//debugText.text = tempString;
			break;
		}
		case 17:
		{
			score = 0;
			if(mass[1] > 25000000)
			{
				goalComplete = true;
			}
			score = (int)mass[1]-(10000000+((int)game_time*23));
			break;
		}
		case 18:
		{
			score = 0;
			if(mass[1] > 25000000)
			{
				goalComplete = true;
			}
			score = (int)mass[1]-(10000000+((int)game_time*23));
			break;
		}
		case 19:
		{
			score = 0;
			if(false)
			{
				goalComplete = true;
			}
			
			if(scale>=0.0)
				scale -=0.001;
			break;
		}
			/*case 4:
			 {
			 if(mass[1] >= 1500000)
			 goalComplete = true;
			 break;
			 }
			 
			 case 12:
			 {
			 if((mass[1] >= 1500000) && (mass[2] >= 1500000))
			 goalComplete = true;
			 break;
			 }
			 
			 case 13:
			 {
			 if(mass[1] >= 1500000)
			 goalComplete = true;
			 break;
			 }
			 case 14:
			 {
			 if((mass[1] >= 1100000)) //&& (mass[2] >= 1100000))
			 goalComplete = true;
			 break;
			 }
			 case 15:
			 {
			 //if((mass[1] >= 1100000)) //&& (mass[2] >= 1100000))
			 //	goalComplete = true;
			 break;
			 }
			 case 16:
			 {
			 goalComplete = true;
			 for(int i = 1; i<=bodies; i++)
			 {
			 if((mass[i] >= (1000000/15))) //&& (mass[2] >= 1100000))
			 {
			 goalComplete = false;
			 break;
			 }
			 }
			 break;
			 }
			 case 17:
			 {
			 
			 goalComplete = false;
			 
			 }*/
	}
	if(oldscore != score)
	{
	//NSLog(@"IN Goals releasing");
	/*if(debugText.text != NULL)
	{
	//[debugText.text release];
	}
	
	if(newString != NULL)
	{
	//[newString release]; 
	}
	
	if(tempString != NULL)
	{
	//[tempString release];
	}
	
	debugText.frame = CGRectMake(200, 200, 400, 400);
	

	
	newString =[[NSString alloc] initWithCString: "Score\n"];
	//NSString *tempString;	
	
	tempString = [NSString stringWithFormat:@"%i",score];			
	newString = [newString stringByAppendingString:tempString];
	
	
	
	
	
	debugText.text = newString;
	}*/
		
		debugText.text =[NSString stringWithFormat:@"Scores\n%i",score];
		
		
		
	}
		
		//[tempString1 release];
	return goalComplete;
	
}

- (void)pauseAtEnd:(int)levelNumber
{
		levelEnd = true;
	//NSLog(@"Pause at end");
	//This is a specal paused used at the end of levels, it is diferent in that a 
	//new level is loaded when unpaused.
	[self placeScore:score :level];
	[self pause];
	level = levelNumber;

	reloadAfterPause = true;
}
- (void)unpause
{
	
	//NSLog(@"Unpause");	
	
	
	
	debugText.frame = CGRectMake(5, 5, 200, 300);
	//NSString *newString1 =[[NSString alloc] initWithCString: "Score\n"];
	//NSString *tempString1;

		//tempString1 = [NSString stringWithFormat:@"%i",score];			
		//newString1 = [newString1 stringByAppendingString:tempString1];

		//[tempString1 release];
		
		if(!(level==0|| level==1|| level == 19))
			debugText.text =[NSString stringWithFormat:@"Score\n%i",score];
		else{
			debugText.text =[NSString stringWithFormat:@""];
		}
	//debugText.text = newString1;	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//Used when unpausing, if pauseAtEnd is used, a new level is loaded when unpausing
	if(reloadAfterPause)
	{
		[self LoadLevel :level];
	}
	
	if(level ==15 || level == 17 || level == 18)
		debugText.frame = CGRectMake(0, 360, 320, 50);
	else
		debugText.frame = CGRectMake(0,0 , 320, 50);
	paused = false;
}
- (void)pause
{
	if(!paused)
	{
		//NSLog(@"Pause");
		//debugText.frame = CGRectMake(100, 100, 200, 300);
		
		
		//newString =[[NSString alloc] initWithCString: "Heigh Scores\n"];
		
		/*for(int i = 0; i<10;i++)
		 {
		 tempString = [NSString stringWithFormat:@"%i",scores[(level*10)+i]];			
		 newString = [newString stringByAppendingString:tempString];
		 //[tempString1 release];
		 tempString =[[NSString alloc] initWithCString: "\n"];
		 
		 //tempString = [NSString stringWithFormat:@"%i",scores[(level+10)+i]];			
		 newString = [newString stringByAppendingString:tempString];
		 //[tempString1 release];
		 
		 
		 }*/
		/*if(debugText.text != NULL)
		 {
		 NSLog(@"releasing dedubTExt.text %@",debugText.text);
		 
		 }*/
		//if (!(debugText.text == 0 ))
		//if (!(debugText.text == nil || [debugText.text isKindOfClass:[NSNull class]])) 
			
			{
				//NSLog(@"Trying to release debufText.text");
				
				//[debugText.text release];
			}
		switch (level) {
			case 1:
				case 4:
				case 5:
				case 6:
				case 7:
				//case 17:
				//case 18:
				
							debugText.frame = CGRectMake(HSPos1X, HSPos1Y, 320, 140);
							
			
				break;
			
			case 2:
				case 3:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
				case 13:
				case 17:				

			case 18:
				
							debugText.frame = CGRectMake(HSPos2X, HSPos2Y, 320, 280);
				
				break;
			case 16:
			case 15:
				case 14:
							debugText.frame = CGRectMake(100, 50, 240, 280);
				break;
				
				
				//case 1:
				


		}
if(!(level==0||level==1||level==19))
{
	if(!levelEnd)
	{
			debugText.text =[NSString stringWithFormat:@"High Scores\n\t1: %i   2: %i\n   3: %i   4: %i\n   5: %i   6: %i\n   7: %i   8: %i\n   9: %i   10: %i\n",scores[(level*10)+0],scores[(level*10)+1],scores[(level*10)+2],scores[(level*10)+3],scores[(level*10)+4],scores[(level*10)+5],scores[(level*10)+6],scores[(level*10)+7],scores[(level*10)+8],scores[(level*10)+9],scores[(level*10)+10]];
	}
	if(levelEnd)
	{
					debugText.text =[NSString stringWithFormat:@"LEVEL COMPLETE!\nScore : %i\n\nHigh Scores\n   1: %i   2: %i\n   3: %i   4: %i\n   5: %i   6: %i\n   7: %i   8: %i\n   9: %i   10: %i\n",score,scores[(level*10)+0],scores[(level*10)+1],scores[(level*10)+2],scores[(level*10)+3],scores[(level*10)+4],scores[(level*10)+5],scores[(level*10)+6],scores[(level*10)+7],scores[(level*10)+8],scores[(level*10)+9],scores[(level*10)+10]];
	}
}
		else{
			debugText.text =[NSString stringWithFormat:@""];
		}
			//[debugText.text release];
			//debugText.text = newString;
			//Run of the mill pause, makes everything stop
			reloadAfterPause = false;
			//[newString1 release];
			//[tempString release];
			paused = true;
		}
	}
	/* This Method Makes a Body which as a bomb and will explode on colition with a non
 * Bomb, Non curser body. Shit Blowing up is cool. >:] */
- (void)MakeBomb:(double)bx :(double)by
{
	/*NSLog(@"make bomb");
	// This code checks for other bombs, so that creation of a 2nd bomb can be prevented
	 */
	bool noOtherBombs = true;	
	for(int i = 0; i <= bodies; i++)
	{
		if(bomb[i] == true)
		{
			noOtherBombs = false;
			break;
		}
	}	
	 /*
	if(noOtherBombs||infiniteBombs) //Removed to replicate bug, Consider changeing to counter, if(bombds<MaxBombs)
	{
		/*
		bombCount = 0; //Just taking advantage of costly test
		
		
		if(bodies < 253) //Dont Ever go over 254 bodies, EVER!
		{
			bodies++;
			bombCount++;
			// This is not an oversight, if bodies equals 255 i want 255 to be taken and used as a bomb		
			mass[bodies]=100000;
			applyPhysics[bodies] =true;
			// Make at the UFO's Position
			x[bodies] = x[0];
			y[bodies] = y[0];	
			TTL[bodies] = false;
			// Its a bomb
			bomb[bodies] = true;
			// No Inital Velocity
			velx[bodies] = 0;
			vely[bodies] = 0;
			noJoinTime[bodies] = 0.0;
			// r is the sq root of mass, just like most bodies
			r[bodies] = sqrt(mass[bodies]);
			/* Only the Iron view is used, but passig null views seems like a bad idea
			 * and the logic involved in skipping the view in the main loop isn't worth
			 * the performace hit */
		/*
			ironView[bodies] = [[UIImageView alloc] initWithImage:bombImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:bombImage];
			rockView[bodies] = [[UIImageView alloc] initWithImage:bombImage];
			// Only draw the Iron View	
			
			iron[bodies] = 1.0;
			rock[bodies] = 0.0;
			h20[bodies] = 0.0;
			
			
			
			ironView[bodies].alpha =1.0;
			rockView[bodies].alpha =0.0;
			h20View[bodies].alpha =0.0;
		}
	} //End if
		NSLog(@"bomb made");
*/

		
		
		
		
		
		
		
		//NSLog(@"blackhole");	// This code checks for other bombs, so that creation of a 2nd bomb can be prevented
		/*bool noOtherBombs = true;	
		 for(int i = 0; i <= bodies; i++)
		 {
		 if(bomb[i] == true)
		 {
		 noOtherBombs = false;
		 break;
		 }
		 }	
		 if(noOtherBombs||infiniteBombs) //Removed to replicate bug, Consider changeing to counter, if(bombds<MaxBombs)
		 {*/
		bombCount = 0; //Just taking advantage of costly test		
		
		if(bodies < 110) //Dont Ever go over 254 bodies, EVER!
		{
			bodies++;
			bombCount++;
			// This is not an oversight, if bodies equals 255 i want 255 to be taken and used as a bomb		
			mass[bodies]=100000;
			applyPhysics[bodies] =false;
			// Make at the UFO's Position
			x[bodies] = x[0];
			y[bodies] = y[0];
			//hasTTL[bodies] = true;
			//TTL[bodies] = 10.0;
			// Its a bomb
			bomb[bodies] = true;
			// No Inital Velocity
			velx[bodies] = 0;
			vely[bodies] = 0;
			applyPhysics[bodies] =true;
			noJoinTime[bodies] = 0.0;
			// r is the sq root of mass, just like most bodies
			r[bodies] = sqrt(mass[bodies]);
			iron[bodies] = 1.0;
			rock[bodies] = 0.0;
			h20[bodies] =0.0;
			/* Only the Iron view is used, but passig null views seems like a bad idea
			 * and the logic involved in skipping the view in the main loop isn't worth
			 * the performace hit */
			ironView[bodies] = [[UIImageView alloc] initWithImage:bombImage];
			h20View[bodies] = [[UIImageView alloc] initWithImage:bombImage];
			rockView[bodies] = [[UIImageView alloc] initWithImage:bombImage];
			// Only draw the Iron View		
			ironView[bodies].alpha =1.0;
			rockView[bodies].alpha =0.0;
			h20View[bodies].alpha =0.0;
		}
		//} //End if
}// End Method
- (void)MakeBlackHole//:(double)bx :(double)by
{
	//NSLog(@"blackhole");	// This code checks for other bombs, so that creation of a 2nd bomb can be prevented
	/*bool noOtherBombs = true;	
	 for(int i = 0; i <= bodies; i++)
	 {
	 if(bomb[i] == true)
	 {
	 noOtherBombs = false;
	 break;
	 }
	 }	
	 if(noOtherBombs||infiniteBombs) //Removed to replicate bug, Consider changeing to counter, if(bombds<MaxBombs)
	 {*/
	bombCount = 0; //Just taking advantage of costly test		
	
	if(bodies < 253) //Dont Ever go over 254 bodies, EVER!
	{
		bodies++;
		//bombCount++;
		// This is not an oversight, if bodies equals 255 i want 255 to be taken and used as a bomb		
		mass[bodies]=1000000;
		applyPhysics[bodies] =false;
		// Make at the UFO's Position
		x[bodies] = x[0];
		y[bodies] = y[0];
		hasTTL[bodies] = true;
		TTL[bodies] = 10.0;
		// Its a bomb
		bomb[bodies] = false;
		// No Inital Velocity
		velx[bodies] = 0;
		vely[bodies] = 0;
		noJoinTime[bodies] = 0.0;
		// r is the sq root of mass, just like most bodies
		r[bodies] = 1000;
		iron[bodies] = 1.0;
		rock[bodies] = 0.0;
		h20[bodies] =0.0;
		/* Only the Iron view is used, but passig null views seems like a bad idea
		 * and the logic involved in skipping the view in the main loop isn't worth
		 * the performace hit */
		ironView[bodies] = [[UIImageView alloc] initWithImage:gravImage];
		h20View[bodies] = [[UIImageView alloc] initWithImage:gravImage];
		rockView[bodies] = [[UIImageView alloc] initWithImage:gravImage];
		// Only draw the Iron View		
		ironView[bodies].alpha =1.0;
		rockView[bodies].alpha =0.0;
		h20View[bodies].alpha =0.0;
	}
	//} //End if
}// End Method
/* This method is a biggie, It takes a bomb and the body it colided with and makes a
 * Bunch of smaller bodies; Chunks from the exploded body */
- (void)Boom:(int) bodyno: (int) bombno
{
	//NSLog(@"Boom");
	// For debuging TODO remove in final
	//bool isBodyBomb = bomb[bodyno];
	//double bmass = mass[bodyno];
	//double bX = x[bodyno];
	//double bY= y [bodyno];
	//double bVelX = velx[bodyno];
	//double bVely = vely[bodyno];
	
	// Don't let 1 bomb destroy anyother
	if(!bomb[bodyno]) // && bomb[bombno] is redundant
	{
		double rockMass;
		double h20Mass;
		double ironMass;
		
		rockMass = mass[bodyno] * rock[bodyno];
		h20Mass = mass[bodyno] * h20[bodyno];
		ironMass = mass[bodyno] * iron[bodyno];
		
		double massToFill;
		
		double newRockMass, newH20Mass, newIronMass;
		
		int ran = 0;
		//mass[bodyno] += mass[bombno]; //Not strictly neccary but couldn't help myself
		
		
		/* Now we start making the pieces of the exploded bomb, Each iteration of this
		 * loop makes one piece */
		//Start at the current bodynumber, finish when we useup all the mass from the exploded body
		for(int i = (bodies+1); mass[bodyno] >= 0 ; i++)
		{ 
			// Don't overflow buffer
			if(bodies>110)
				break;
			// increase number of bodies to make room for the new body
			bodies++;
			arc4random_stir();
			// Asign a random mass greater than a minimum and Third of the exploded bodys mass
			// TODO loose magic number
			/*int saftey = 0;
			 while(mass[i] < 100)
			 {
			 mass[i] = (int)(arc4random() +10000) % (int)((mass[bodyno]/5)+1); // TODO the +1 prevents divide by zero but may leak mass from the inverse
			 if(saftey > 100)
			 break;
			 
			 saftey++;
			 }*/
			newH20Mass = newIronMass = newRockMass = 0;
			mass[i] = mass[bodyno]/5;
			massToFill = mass[i];
			while(massToFill > 0.0)
			{
				
				// I want to keep adding iron, rock, h20, until i fill the mass
				// i want to use the materials in that order because of weight
				// it makes more sence that the larger bodys would be the heavier material
				if(ironMass > 0)
				{
					if(ironMass < massToFill) //If i can throw all of the ironmass into the new one
					{
						newIronMass += ironMass;
						massToFill -= ironMass;
						ironMass = 0;
					}
					else //If i can't throw the whole thing in, ie. i can fill it
					{
						newIronMass += massToFill;
						ironMass -= massToFill;
						massToFill = 0;
					}
				}
				else if(rockMass > 0)
				{
					if(rockMass < massToFill) //If i can throw all of the ironmass into the new one
					{
						newRockMass += rockMass;
						massToFill -= rockMass;
						rockMass = 0;
					}
					else //If i can't throw the whole thing in, ie. i can fill it
					{
						newRockMass += massToFill;
						rockMass -= massToFill;
						massToFill = 0;
					}
				}
				else if(h20Mass > 0)
				{
					if(h20Mass < massToFill) //If i can throw all of the ironmass into the new one
					{
						newH20Mass += h20Mass;
						massToFill -= h20Mass;
						h20Mass = 0;
					}
					else //If i can't throw the whole thing in, ie. i can fill it
					{
						newH20Mass += massToFill;
						h20Mass -= massToFill;
						massToFill = 0;
					}
				}
				else
				{break;}
			}
			// Make r the sq root of mass
			r[i] = sqrt(mass[i]);
			// Remove the mass of the new body from the exploded body			
			mass[bodyno] -= mass[i];
			arc4random_stir();
			
			
			
			//I broke this down for debuging
			//x[i] = (double)((int)((arc4random()-(int)r[bodyno]*1)+r[i]) % (int)((r[bodyno]*1)-r[i])+1) + x[bodyno];
			// Get a radom number no greater that Twice the diamiter
			double tempRand = arc4random()%1000;//%((int)(r[bodyno]*4));
			// And subtract the diamiter from it, to get a random point with in the original circle TODO: remember why i did it this way
			tempRand -= r[bodyno]*2;
			tempRand += r[i];
			// TODO: Could i have ANY random number since it's going to get moded in a moment anyway?
			// I want the body to be inside the original body so i will mod:
			double divisor = r[bodyno]; //The original radius to make sure the center is inside
			divisor -= r[i];  //minus the peices radius to make sure the edge of the boay is inside
			if((int)divisor <= 0){divisor = 1;}	//Prevent devide by zero, mod includes divide
			tempRand =(int)tempRand % (int)divisor; // Do the actual mod, use tempRand to store the result
			tempRand += x[bodyno]; // We have a point withing the radius, add x to get a golbal point
			x[i] = tempRand; //Finaly assign it
			
			
			//y[i] = (double)((int)((arc4random()-(int)r[bodyno]*1)+r[i]) % (int)((r[bodyno]*1)-r[i])+1) + y[bodyno];			
			//Same as above for Y
			arc4random_stir();
			tempRand = arc4random()%1000;//%((int)(r[bodyno]*4));
			tempRand -= r[bodyno]*2;
			tempRand += r[i];
			divisor = r[bodyno];
			divisor -= r[i];
			if((int)divisor <= 0)
			{divisor = 1;}		
			tempRand = (int)tempRand % (int)divisor;
			tempRand += y[bodyno];
			y[i] = tempRand;
			
			// Setup Velocity as original bodys velocity + it's position relitive to original center deived by mass
			// This has the effect of sending bodies away from the original center, ligher ones getting blown away more easily
			//BUGFIX this favors the +x +y direction to much, should have an equal chance at -x, -y
			if((int)arc4random()%2 == 0)
			{
				velx[i] = velx[bodyno]+ (((arc4random()%10))/((mass[i]+1)/1000));
				vely[i] = vely[bodyno]+ (((arc4random()%10))/((mass[i]+1)/1000));
			}
			else
			{
				velx[i] = velx[bodyno]- (((arc4random()%10))/((mass[i]+1)/1000));
				vely[i] = vely[bodyno]- (((arc4random()%10))/((mass[i]+1)/1000));
			}
			//vely[i] = vely[bodyno]+ ((int)(((y[i]-y[bodyno])*100)/mass[i])/(int)1);
			
			// No Joint time means the new bodies have a number of seconds of imunity from eachothers gravity, prevents instant
			// rejoining, important for playability.
			noJoinTime[i] = noJoin;	
			// The pieces aren't bombs TODO make this random in demo mode			
			bomb[i] = chainReact;			
			//Material
			
			rock[i] = newRockMass / mass[i];
			h20[i] = newH20Mass / mass[i];
			iron[i] = newIronMass / mass[i];
			
			
			
			ironView[i] = [[UIImageView alloc] initWithImage:smallIronImage];
			h20View[i] = [[UIImageView alloc] initWithImage:smallH20Image];
			rockView[i] = [[UIImageView alloc] initWithImage:smallRockImage];
			// TODO material properly, under a sertain mass is always pure, remove from overall, precalc mass of each component material
			rockView[i].alpha =1.0;
			ironView[i].alpha =iron[i];
			h20View[i].alpha =h20[i];
			applyPhysics[i] = true;
			
			//If on the 20th piece, nearly out of mass or reaching end of buffer, end
			ran++;			
			if(mass[i] <= 1000 || ran >= 20 || bodies > 250)
			{
				// give remaining mass to last piece
				mass[i] = 	mass[bodyno];
				//kill the original body
				//[self destroyBody : bodyno];
				break;
			}
		}//End of For loop
		//When done, destroy original
		bombCount--;
		//NSLog(@"Destoryed cause explodee");
		[self destroyBody : bodyno]; 
		//BUGFIX, since bodyno has been removed from array and everything above it moved down by one
		//The position bombno refers to is 1 too high and is decremented to refer to thebodies new position
		if(bodyno<bombno)
			bombno--;
		//NSLog(@"Destoryed cause exploder");
		[self destroyBody : bombno]; //Remove the bomb
		
	}//End of if
}//End of method
/* This method handles removing bodies from the universe */
- (void)destroyBody:(int) body
{
	//rockView[body].alpha =0.0;
	//ironView[body].alpha =0.0;
	//h20View[body].alpha =0.0;
	// Remove it's views from the main view
	//NSLog(@"destroy body began");
	if(rockView[body] == NULL||ironView[body] == NULL||h20View[body] == NULL||rockView[body] == nil||h20View[body] == nil||ironView[body] == nil)
	{
		
		//NSLog(@"NULL found at %i ob: %@",body,rockView[body]);
	}
	else
	{

		
		//NSLog(@"Releasing Views ob: %@",body,rockView[body]);
		@try
		{
			//NSLog(@"Not Null by test removing from superview");
			[rockView[body] removeFromSuperview];
			[ironView[body] removeFromSuperview];
			[h20View[body] removeFromSuperview];
			//NSLog(@"removing from superview done");
			[ironView[body] release];
		}
		@catch (NSException *exception) {
			//NSLog(@"This aint good releasing in destroybody %@: %@",[exception name],[exception reason]);
			
			
		}
		@finally
		{
		}	
		@try
		{
			[h20View[body] release];
		}
		@catch (NSException *exception) {
			NSLog(@"This aint good releasing in destroybody %@: %@",[exception name],[exception reason]);
			
			
		}
		@finally
		{
		}	
		
		@try
		{
			[rockView[body] release];
		}
		@catch (NSException *exception) {
			//NSLog(@"This aint good releasing in destroybody %@: %@",[exception name],[exception reason]);
			
			
		}
		@finally
		{
		}
		
		//NSLog(@"Views released");
	}
	// Free up the views memory 
	//[rockView[body] dealloc];
	//[ironView[body] dealloc];
	//[h20View[body] dealloc];
	//Just in case make 0
	//mass[body]=0;
	//r[body] =0;	
	if(bomb[body])
	{
		bombCount--;
	}
		/* So now we have an unused piece of the arrays, bring everything down one */
	for(int i = body; i < bodies; i++)
	{
		//if(mass[i] < 
		mass[i] = mass[i+1];
		r[i] = r[i+1];
		x[i] = x[i+1];
		y[i] = y[i+1];
		
		velx[i] = velx[i+1];
		vely[i] = vely[i+1];
		
		//r[i] = r[i+1];
		TTL[i] = TTL[i+1];
		hasTTL[i] = hasTTL[i+1];
		iron[i] = iron[i+1];
		h20[i] = h20[i+1];
		rock[i] = rock[i+1];
		
		bomb[i] = bomb[i+1];
		
		noJoinTime[i] = noJoinTime[i+1];
		
		
		//NSLog(@"Reasigning Views");
		rockView[i] = rockView[i+1];
		ironView[i] = ironView[i+1];
		h20View[i] = h20View[i+1];
		
		applyPhysics[i] = applyPhysics[i+1];
		
	}
	
	// Just in case
	mass[bodies] = 0;
	
	r[bodies] = 0;
	x[bodies] = 0;
	y[bodies] = 0;
	
	velx[bodies] = 0;
	vely[bodies] = 0;
	
	mass[bodies] = 0;
	r[bodies] = 0;
	hasTTL[bodies] = false;
	TTL[bodies] = 0;
	
	
	iron[bodies] = 0;
	h20[bodies] = 0;
	rock[bodies] = 0;
	noJoinTime[bodies]=0.0;
	bomb[bodies] = 0;
	
	applyPhysics[bodies] = 0;
	// Reduce the overall number of bodies
	//bomb[bodies] = true;

	//[rockView[bodies] removeFromSuperview];
	//[ironView[bodies] removeFromSuperview];
	//[h20View[bodies] removeFromSuperview];

	bomb[bodies] = false;
	mass[bodies] = 10000;
	r[bodies] = 100;
	x[bodies] = x[0];
	y[bodies] = y[0];
	
	iron[bodies] = 0;
	h20[bodies] = 0;
	rock[bodies] = 0;
	//if(ironView[bodies] != NULL)		
	//{
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
	//}

	//[h20View[bodies] release];
	//[rockView[bodies] release];
	
	bodies--;
	//NSLog(@"Removale complete");
	
}
/* Returns the distance between 2 points */
- (double)GetDist:(double)x1 :(double)y1 :(double)x2 :(double)y2
{	
	return (double) sqrt(
						 pow((x2-x1), 2) + pow((y2-y1), 2)
						 );
}
/* Gets the angle between 2 points */
- (double)GetAng:(double)x1 :(double)y1 :(double)x2 :(double)y2
{	
	return atan2(y2-y1,x2-x1);
}
/* Handles the touch events, positioning the curser and and handeling the buttons */
- (void) touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
	if(!loading)
	{
	//NSLog(@"touchesbegan");
	/*
	 NSUInteger numTaps = [[touches anyObject]tapCount];
	 NSUInteger numTouches = [touches count];
	 */
	// Get the touch and make it into a point, so i can work with it
	UITouch *touch = [touches anyObject];
	touchPoint = [touch locationInView:self.view];
	
	
	if(touchPoint.y > 410) // Is it on the button bar
	{
		//The buttons change if paused, the first lot are the unpaused buttons
		if(!paused)
		{
			if(touchPoint.x<64)
			{	
				//newString =[[NSString alloc] initWithCString: ""];
				//newString = [newString stringByAppendingString:@"\n Button 1 Presses"];
				if(!locked) //Just incase it fucks up threads
					if(bombsEnabled && (bombCount <1))
					[ self MakeBomb : x[0] : y[0]];			
			}
			if(touchPoint.x>64 && touchPoint.x<128)
			{
				//newString =[[NSString alloc] initWithCString: ""];
				//newString = [newString stringByAppendingString:@"\n Button 2 Presses"];
				if(zeroWait<=zeroShouldWait && zerosEnabled)
				{
					zeroWait = 5.0;
					for (int i = 0; i <= bodies; i++)
					{
						velx[i] = 0;
						vely[i] = 0;
					}
				}
			}
			else if(touchPoint.x>=256 && touchPoint.x<320)
			{
				//newString =[[NSString alloc] initWithCString: ""];
				//newString = [newString stringByAppendingString:@"\n Button 3 Presses"];
				[self pause];			
			}
			else if(touchPoint.x>=128 && touchPoint.x<192)
			{
				//newString =[[NSString alloc] initWithCString: ""];
				//newString = [newString stringByAppendingString:@"\n Button 4 Presses"];
				if(blackHolesEnabled)
				[self MakeBlackHole];
			}
			else if(touchPoint.x>=256)
			{
				//newString =[[NSString alloc] initWithCString: ""];
				//newString = [newString stringByAppendingString:@"\n Button 5 Presses"];
				
			}
			//debugText.text = newString;	
		}
		else if(paused)
		{
			/*
			 newString =[[NSString alloc] initWithCString: ""];
			 newString = [newString stringByAppendingString:@"\n Paused"];
			 debugText.text = newString;	
			 */
			
			if(touchPoint.x<64)
			{
				[self pauseAtEnd: (level - 1)];
				[self unpause];
			}
			else if(touchPoint.x>64 && touchPoint.x<128)
			{
				[self pauseAtEnd: (level + 1)];
				[self unpause];
			}
			else if(touchPoint.x>128 && touchPoint.x<192)
			{
				
				[self unpause];
			}
			else if(touchPoint.x>192 && touchPoint.x<256)
			{
			}
			else if(touchPoint.x<256)
			{
			}
			
		}
		
	}
	else{
		if(curserCanMove)
		{
			//[self SaveState];
			
			
			x[0] = touchPoint.x/scale;
			y[0] = touchPoint.y/scale;
			velx[0]=0;
			vely[0]=0;
		}
	}
	}
}

- (void) touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
	
	//NSLog(@"touchesMoved");
	/*
	 NSUInteger numTaps = [[touches anyObject]tapCount];
	 NSUInteger numTouches = [touches count];
	 */
	// Get the touch and make it into a point, so i can work with it
	UITouch *touch = [touches anyObject];
	touchPoint = [touch locationInView:self.view];
	
	
	if(touchPoint.y > 410) // Is it on the button bar
	{
		/*
		 //The buttons change if paused, the first lot are the unpaused buttons
		 if(!paused)
		 {
		 if(touchPoint.x<64)
		 {	
		 //newString =[[NSString alloc] initWithCString: ""];
		 //newString = [newString stringByAppendingString:@"\n Button 1 Presses"];
		 if(!locked) //Just incase it fucks up threads
		 [ self MakeBomb : x[0] : y[0]];			
		 }
		 if(touchPoint.x>64 && touchPoint.x<128)
		 {
		 //newString =[[NSString alloc] initWithCString: ""];
		 //newString = [newString stringByAppendingString:@"\n Button 2 Presses"];
		 if(zeroWait<=zeroShouldWait)
		 {
		 zeroWait = 5.0;
		 for (int i = 0; i <= bodies; i++)
		 {
		 velx[i] = 0;
		 vely[i] = 0;
		 }
		 }
		 }
		 else if(touchPoint.x>=128 && touchPoint.x<192)
		 {
		 //newString =[[NSString alloc] initWithCString: ""];
		 //newString = [newString stringByAppendingString:@"\n Button 3 Presses"];
		 [self pause];			
		 }
		 else if(touchPoint.x>=192 && touchPoint.x<256)
		 {
		 //newString =[[NSString alloc] initWithCString: ""];
		 //newString = [newString stringByAppendingString:@"\n Button 4 Presses"];
		 [self MakeBlackHole];
		 }
		 else if(touchPoint.x>=256)
		 {
		 //newString =[[NSString alloc] initWithCString: ""];
		 //newString = [newString stringByAppendingString:@"\n Button 5 Presses"];
		 
		 }
		 //debugText.text = newString;	
		 }
		 else if(paused)
		 {
		 
		 
		 if(touchPoint.x<64)
		 {
		 [self pauseAtEnd: (level - 1)];
		 [self unpause];
		 }
		 else if(touchPoint.x>64 && touchPoint.x<128)
		 {
		 [self pauseAtEnd: (level + 1)];
		 [self unpause];
		 }
		 else if(touchPoint.x>128 && touchPoint.x<192)
		 {
		 
		 [self unpause];
		 }
		 else if(touchPoint.x>192 && touchPoint.x<256)
		 {
		 }
		 else if(touchPoint.x<256)
		 {
		 }
		 
		 }
		 */
	}
	else{
		if(curserCanMove)
		{
			x[0] = touchPoint.x/scale;
			y[0] = touchPoint.y/scale;
			velx[0]=0;
			vely[0]=0;
		}
	}	
}	
/* Du-Du-dun! the Main game loop, It runs on a timer every loopinterval (0.05 seconds) */
- (void)onTimer
{
	if(!loading)
	{
	@try{
	//NSLog(@"In timer bodies:%i",bodies);
	double dist;
	double ang;
	double force;
	double v;
	//NSLog(@"In the big loop");
	//BGView = [[UIImageView alloc] initWithImage:rockImage];	
	//BGView.frame = CGRectMake(0, 0, swidth, sheight);
	
	//BGView.alpha = 1.0;
	//BGView.opaque = true;
	//[self.view addSubview:BGView];	
		app_time +=loopInterval;
	locked = true; //if Timer is a thread this is good practice, if it isn't it doesn't matter
	if((!paused)||(level==0))
	{
		/*******************************************************************************************************
		 *											Deal With Spawn Points
		 *******************************************************************************************************/
		if(spawn)
		{
			spawnTimeLeft -= loopInterval;
			if(spawnTimeLeft <= 0.0)
			{
				if(bodies < 253) //Dont Ever go over 254 bodies, EVER!
				{
					bodies++;
					// This is not an oversight, if bodies equals 255 i want 255 to be taken and used as a bomb		
					mass[bodies]= spawnedMass;
					applyPhysics[bodies] =true;
					// Make at the UFO's Position
					x[bodies] = spawnX;
					y[bodies] = spawnY;	
					// Its a bomb
					bomb[bodies] = spawnBomb;
					// No Inital Velocity
					velx[bodies] = spawnedVelX;
					vely[bodies] = spawnedVelY;
					// r is the sq root of mass, just like most bodies
					r[bodies] = sqrt(mass[bodies]);
					/* Only the Iron view is used, but passig null views seems like a bad idea
					 * and the logic involved in skipping the view in the main loop isn't worth
					 * the performace hit */
					ironView[bodies] = [[UIImageView alloc] initWithImage:smallIronImage];
					h20View[bodies] = [[UIImageView alloc] initWithImage:smallH20Image];
					rockView[bodies] = [[UIImageView alloc] initWithImage:smallRockImage];
					// Only draw the Iron View
					h20[bodies] = iron[bodies] = rock[bodies] = 0.0;
					
					if((H20Prob+IronProb+RockProb) != 0)
					{
						int temp = (int)arc4random() % (int)(H20Prob+IronProb+RockProb);
						if(temp < 0)
							temp = temp * -1;
						if(temp <= H20Prob)
						{
							h20[bodies] = 1.0;
						}
						else if((temp>H20Prob)&&(temp <=(H20Prob+IronProb)))
						{
							iron[bodies] = 1.0;
						}
						else if((temp>(H20Prob+IronProb)) && (temp<=(H20Prob+IronProb+RockProb)))
						{
							rock[bodies] = 1.0;
						}
					}
					else
					{
						iron[bodies] = 1.0;
					}
					
					ironView[bodies].alpha = iron[bodies];
					rockView[bodies].alpha =1.0;
					h20View[bodies].alpha =h20[bodies];
				}
				spawnTimeLeft = spawnTime;
			}
		}//End Spawn Point Stuff
		
		game_time += loopInterval;
		
		// Handles disabling the momentom 0 for a time
		if(zeroWait>0.0)
		{
			zeroWait-=loopInterval;
			if(zeroWait < 0.0)
			{
				zeroWait = 0.0;
			}
		}
		//NSLog(@"2");
		/***********************************************************************************************************************************
		 **									The big for loop applies forces between pairs of objects									  **
		 **********************************************************************************************************************************/
		for(int i = 0;i<=bodies;i++)
		{
			// Boilerplate, prevent overrun
			if(i > 254)	break;
			
			// Tick down noJointTime, this is used to give bodies a moment of imunity after an explotion,
			// Prevents instant Rejoining
			if(noJoinTime[i]>0.0) noJoinTime[i]-=loopInterval;
			
			// TimeToLive is used for gravity well bodies made by the player they are removed after a time.
			if(hasTTL[i])
			{
				if(TTL[i] <= 0)
				{//NSLog(@"Destoryed cause TTL  0");
					[self destroyBody:i];
					i--; //It is essental to do this after a destroyBody inside the loop
					break; //The body no longer exists break.
				}
				else{
					TTL[i] -= loopInterval;
				}
			}
			
			//**************************                      Physics Here                          *****************************/
			
			// This sets up the second body that will be compared, have forces applied
			for(int j =0; j <= bodies; j++)
			{
				if(i > 254)	break; //Boilerplate
				
				if((i != j)) // Make sure we aren't comparing the body to it's self //&& mass[j] > 0.0 && mass[i] > 0.0)
				{
					//  Were applying the velocity of gravity to every body from every bodie but not to it's self,
					//  That would just be silly
					
					
					
					

					
					
					
					
					
					
					
					dist = [self GetDist :x[i] :y[i] :x[j] :y[j]];	// Get distant between the 2 bodies
					if (dist < 0.00001) dist = 0.00001;						// Prevent /0
					ang = [self GetAng :x[i] :y[i] :x[j] :y[j]];		// Get angle between the 2 bodies
					// Find the gravitation force of gravity between the 2 bodies, thanks Isaac
					force = (grav * (mass[i] * mass[j])) / ((dist *dist)/10);
					v = force / mass[i];							// Get the velocity that force would apply
					
					//************************** Apply the new velocity to the current velocity *******************************
					if(!(													// Unless
						 ((j==0 || i==0) && (dist < noEffectR))				// 1 of the bodies is the curser and the other is inside the sweetspot
						 ||													// OR
						 (noJoinTime[i]>0.0 && noJoinTime[j]>0.0)			// Both of them is exempted from physics
						 ))													// Go ahead and apply physics
					{
						/* If the bodys are on no join time or in noeffect R. dont add velocity for those particular
						 * bodies. */
						velx[i] += 0.0001 * (v * cos(ang))/t;
						vely[i] += 0.0001 * (v * sin(ang))/t;
					}
					
					//*************************                 Join Bodies                 **********************************
					if(!(i==0 || j==0) &&									// If nither is the UFO and
					   !(noJoinTime[i]>0.0 || noJoinTime[j]>0.0) &&			// nither is exempt from joining and
					   (dist<((r[i]*0.5)+(r[j]*0.5))))						// the objects are overlapping
					{
						/* If ether is a bomb and neither is the courser */
						if((bomb[i] || bomb[j])&&!(i==0 || j==0)&&!(bomb[i]&&bomb[j])&&(applyPhysics[i]&&applyPhysics[j]))
						{
							if(bomb[j])
							{
								[self Boom : i : j];
							}
							else
							{
								[self Boom : j : i];
							}
						}
						
						/* For all the other bodies, not bombs or curser */
						else
						{
							if(((mass[i] > mass[j]) || (applyPhysics[i] == false))  && (applyPhysics[j]==true))
							{
								if(!(applyPhysics[i]==false &&	noAppliesGrow == false))
								{
									//Deal with veloctiy and materials
									rock[i] = ((rock[i]*mass[i])/(mass[i]+mass[j]))+((rock[j]*mass[j])/(mass[i]+mass[j]));
									h20[i] = ((h20[i]*mass[i])/(mass[i]+mass[j]))+((h20[j]*mass[j])/(mass[i]+mass[j]));
									iron[i] = ((iron[i]*mass[i])/(mass[i]+mass[j]))+((iron[j]*mass[j])/(mass[i]+mass[j]));
									
									velx[i] = ((velx[i]*mass[i])/(mass[j]+mass[i]))  +   ((velx[j]*mass[j])/(mass[j]+mass[i]));
									vely[i] = ((vely[i]*mass[i])/(mass[j]+mass[i]))  +   ((vely[j]*mass[j])/(mass[j]+mass[i]));									
									
									mass[i] += mass[j];
									r[i] = sqrt(mass[i]);									
								}
								
								
								rockView[i].alpha =1;//rock[i];
								ironView[i].alpha =iron[i];
								h20View[i].alpha =h20[i];
								//BUG WARNING everything above destroyed body is now is old value -1
								//NSLog(@"Destoryed cause join j");
								[self destroyBody :j];
								/*Bugfix: j is no longer the body we think it is so we break to avoid the calcs that follow
								 *Since j is now what was j+1 and the next loop will run on j+2 we do j-- so that j+1 gets to
								 *run. Beware destroyBody() it works well but everything above the destryed body is moved down
								 *1 place so a simple int will often be pointing to the body above where it was */
								j--;
								break;
							}
							else if(((mass[j] > mass[i]) || (applyPhysics[j] == false))  && (applyPhysics[i]==true))
							{
								//[self Boom : j : i];
								if(!(applyPhysics[j]==false &&	noAppliesGrow == false))
								{
									rock[j] = ((rock[i]*mass[i])/(mass[i]+mass[j]))+((rock[j]*mass[j])/(mass[i]+mass[j]));
									h20[j] = ((h20[i]*mass[i])/(mass[i]+mass[j]))+((h20[j]*mass[j])/(mass[i]+mass[j]));
									iron[j] = ((iron[i]*mass[i])/(mass[i]+mass[j]))+((iron[j]*mass[j])/(mass[i]+mass[j]));
									//TODO Test bellow 2 lines
									velx[j] = ((velx[i]*mass[i])/(mass[j]+mass[i]))  +   ((velx[j]*mass[j])/(mass[j]+mass[i]));
									vely[j] = ((vely[i]*mass[i])/(mass[j]+mass[i]))  +   ((vely[j]*mass[j])/(mass[j]+mass[i]));
									
									mass[j] += mass[i];
									r[j] = sqrt(mass[j]);
								}										
								
								rockView[j].alpha =1.0;//rock[j];
								ironView[j].alpha =iron[j];
								h20View[j].alpha =h20[j];
								
								//NSLog(@"Destoryed cause join i");
								[self destroyBody :i];
								//Bugfix
								i--;
								break;
							}
						}
					}
				}// end 'j' for loop
				//NSLog(@"4");
				//If the body goes out one side of the screen bring it in the other side
				if(x[i] > (swidth + margin)/scale)
				{
					if(killOnExit && (i!=0))
					{//NSLog(@"Calling Destroy body 1");
						[self destroyBody :i];
						i--;
						break;
						break;
						break;
					return;}
					else
					{
						x[i] = (0-margin)/scale;
					}
				}					
				if(x[i] < (0-margin)/scale)
				{
					if(killOnExit && (i!=0))						
					{
						//NSLog(@"Calling Destroy body 2");
						[self destroyBody :i];
						i--;
					break;
					break;
					break;}
					else
					{
						x[i] = (swidth/scale);	//TODO fix margin
					}
				}
				
				if(y[i] > (sheight + margin)/scale)
				{
					if(killOnExit && (i!=0))
					{
						//NSLog(@"Calling Destroy body 3");
						[self destroyBody :i];
						i--;
					break;
						break;
						break;
					return;
					}
					else
					{
						y[i] = (0-margin)/scale;
					}
				}
				
				if(y[i] < (0 - margin) / scale )
				{
					if(killOnExit && (i!=0))
					{
						//NSLog(@"Calling Destroy body 4");
						[self destroyBody :i];
						i--;
						break;
						break;
						break;
						return;
					}
					else
					{
						y[i] = (sheight + margin)/scale;
					}
				}
				if(spawningVelX != 0 || spawningVelY !=0)
				{
					if(spawnX > (swidth + margin)/scale)
						spawnX = (0-margin)/scale;
					if(spawnX < (0-margin)/scale)
						spawnX= (swidth/scale);
					if(spawnY > (sheight + margin)/scale)
						spawnY = (0-margin)/scale;
					if(spawnY < (0 - margin) / scale )
						spawnY = (sheight + margin)/scale;
				}
			}				
			// End Physics
			
			if(killBoxExists && applyPhysics[i])
				if(( x[i] > (killBoxX1) )&&( x[i] < (killBoxX2) ) && //Is it inside the killbox on the x axis
				   ( y[i] > (killBoxY1) )&&( y[i] < (killBoxY2) )&& i != 0) //Is it inside the killbox on the y axis
				{
					if(level == 8  || level== 9 || level == 10)
					{
						int oldscore = score;
						
						score += (100000 -  mass[i])/100;
						
						
						//debugText.frame = CGRectMake(100, 100, 300, 300);
						
						
						if(oldscore != score)
						{
							
							//debugText.text = [[NSString alloc] initWithString: @"Scores\n"];
							//debugText.text =[debugText.text stringByAppendingFormat:@"%i",score];
							
							//if(debugText.text != NULL)
							//[debugText.text release];
							
							
							//if((game_time - old_time)>=1)
							//{
								debugText.text =[NSString stringWithFormat:@"Score:%i\nTime:%i\n",score,(2*60)-(int)game_time];
								//old_time = game_time;
							//}
							//
						//[newString autorelease];
						//[tempString autorelease];
							//NSLog(@"Initalising newstring in killbox section of big loop");
						//newString =[[NSString alloc] initWithCString: "Score1\n"];
						//NS
					//tempString =[newString stringByAppendingFormat:@"%i",score];
						//tempString = [NSString stringWithFormat:@"%i",score];			
						//newString = [newString stringByAppendingString:tempString];
						//NSLog(@"Tempstring release");
						//[tempString release];
						
						

						}
					}
					//NSLog(@"Calling Destroy body");
					[self destroyBody :i];
					i--;
					break;
					break;
					break;
					return;
				}
			//NSLog(@"G");
			//[rockView[i] removeFromSuperview];	
			//[ironView[i] removeFromSuperview];	
			//[h20View[i] removeFromSuperview];			
		}//end 'i' for loop
		
	}
	//debugText.frame = CGRectMake(300, 300, 350, 350);
	/************************************************************************************************************************************
	 ***        Seperate for loop so that bodies removed during loop are not drawn, doing it backwards puts the curser on top         ***
	 ***********************************************************************************************************************************/
	//NSLog(@"5");
	if(killBoxExists)
	{
		killBoxView.frame = CGRectMake(killBoxX1*scale, killBoxY1*scale,((killBoxX2)-(killBoxX1))*scale,((killBoxY2)-(killBoxY1))*scale);	
		[self.view addSubview:killBoxView];
	}
	//if(i == bodies)
		//break;
	
	//NSLog(@"H");
	buttonView[0].opaque = true;
	buttonView[1].opaque = true;
	buttonView[2].opaque = true;
	buttonView[3].opaque = true;
	buttonView[4].opaque = true;
	buttonView[5].opaque = true;
	
	
	
	if(!paused||level==0)
	{
		if(spawningVelX != 0 || spawningVelY !=0)
		{
			spawnX += spawningVelX;
			spawnY += spawningVelY;
		}
		
		for(int i = 0; i <= bodies ;i++)
		{
			if(rockView[i] == NULL||ironView[i] == NULL||h20View[i] == NULL || rockView[i] == nil||ironView[i] == nil||h20View[i] == nil)
		{
			//NSLog(@"NULL found at %i",i);
			[self destroyBody: i];
			i--;
			return;

		}	
			
			else{
				//NSLog(@" %i not null",i);
			}
		}
		
		
		
		for(int i = 0; i <= bodies ;i++)
		{
			//Apply Velocity to the position
			if(applyPhysics[i])
			{
				if(velx[i] > maxSpeed)
				{
					velx[i] = maxSpeed;
					
				}
				if(vely[i] > maxSpeed)
				{
					vely[i] = maxSpeed;
				}
				if(velx[i] < (0- maxSpeed))
				{
					velx[i] = 0 - maxSpeed;					
				}
				if  (vely[i] < (0- maxSpeed))
				{
					vely[i] = 0- maxSpeed;
				}
				
				x[i] += velx[i]*10;
				y[i] += vely[i]*10;
				

				
				// TODO BUG FIX removed 
			}
			

			if(rockView[i] == NULL||ironView[i] == NULL||h20View[i] == NULL)
			{
				//NSLog(@"Still have nulls");
			}
			
			if(mass[i]>0.0)
			{
			//NSLog(@"I1");
				@try {
			//[self.view 		
				

			//NSLog(@"I1.1 instering %i bodies: %i mass:%f x:%f y:%f  rock \n%@ ",i,bodies,mass[i],x[i],y[i],rockView[i]);

			rockView[i].frame = CGRectMake(x[i]*scale -r[i] * scale, y[i]*scale - r[i] * scale, 2 * r[i] * scale, 2 * r[i] *scale);
					//NSLog(@"I1.1 instering %i bodies: %i mass:%f x:%f y:%f  iron \n%@ ",i,bodies,mass[i],x[i],y[i],ironView[i]);
					

			
					ironView[i].frame = CGRectMake(x[i]*scale -r[i] * scale, y[i]*scale - r[i] * scale, 2 * r[i] * scale, 2 * r[i] *scale);
			
										//NSLog(@"I1.1 instering %i bodies: %i mass:%f x:%f y:%f  ice  \n%@ ",i,bodies,mass[i],x[i],y[i],h20View[i]);
					
					
					
					h20View[i].frame = CGRectMake(x[i]*scale -r[i] * scale, y[i]*scale - r[i] * scale, 2 * r[i] * scale, 2 * r[i] *scale);
			//NSLog(@"I1.2");
			rockView[i].alpha = 1.0;
			rockView[i].opaque = true;
			//NSLog(@"I1.5");
					
					if(i == 0)
					{
			[self.view addSubview:rockView[i]];
					//NSLog(@"Drawing iron view at %i alpha %f",i,ironView[i].alpha);
					//NSLog(@"Drawing rock view at %i alpha %f",i,rockView[i].alpha);
					//NSLog(@"Drawing h20  view at %i alpha %f",i,h20View[i].alpha);
			[self.view addSubview:ironView[i]];	
			[self.view addSubview:h20View[i]];	
					}
					else
					{
					
						[self.view insertSubview:rockView[i] aboveSubview: h20View[i-1]];
						[self.view insertSubview:ironView[i] aboveSubview: rockView[i]];
						[self.view insertSubview:h20View[i] aboveSubview: ironView[i]];
					}
			//NSLog(@"I2");
				}
				@catch (NSException * e) {
					[self LoadLevel:0];
					NSLog(@"BAD I=%i",i);
				
				}
				@finally {
					
				}
			}
			
		}
		//NSLog(@"I2.1");
		menuBar.frame = CGRectMake(0, 410, 320, 50);
		[self.view addSubview:menuBar];
		
		
		if([self goalTest])
		{
			[self pauseAtEnd: level +1];
		}
		//NSLog(@"I2.3");
		for(int i =3; i<=5;i++)
		{
			[buttonView[i] removeFromSuperview];
		}
		//NSLog(@"I2.4");
		if(bombsEnabled && (bombCount<1))
		{
			buttonView[0].frame = CGRectMake(0, 410, 64, 50);
			//buttonView[0].alpha =1.0;
			[self.view addSubview:buttonView[0]];
		}
		else
		{
			[buttonView[0] removeFromSuperview];
		}
		//NSLog(@"I2.5");
		if(zeroWait<=0.0)
		{
			buttonView[1].frame = CGRectMake(64, 410, 64, 50);
			//buttonView[1].alpha =1.0;
			[self.view addSubview:buttonView[1]];
		}
		else {
			[buttonView[1] removeFromSuperview];
		}
		//NSLog(@"I2.6");
		if(blackHolesEnabled)
		{
			buttonView[6].frame = CGRectMake(128, 410, 64, 50);
			buttonView[6].alpha =1;
			[self.view addSubview:buttonView[6]];
		}
		//NSLog(@"I2.7");
		buttonView[2].frame = CGRectMake(256, 410, 64, 50);
		buttonView[2].alpha =1;
		[self.view addSubview:buttonView[2]];
		[pauseView[level] removeFromSuperview];
		
	}
	//NSLog(@"I");
	//NSLog(@"6");
	if(paused)
	{
		[self.view addSubview:pauseView[level]];
		for(int i =0; i<=6;i++)
		{
			[buttonView[i] removeFromSuperview];
		}
		//[self.buttonView[3].frame release];
		buttonView[3].frame = CGRectMake(0, 410, 64, 50);
		buttonView[3].alpha =1.0;
		[self.view addSubview:buttonView[3]];
		
		buttonView[4].frame = CGRectMake(64, 410, 64, 50);
		buttonView[4].alpha =1.0;
		[self.view addSubview:buttonView[4]];
		
		
		buttonView[5].frame = CGRectMake(128, 410, 64, 50);
		buttonView[5].alpha =1.0;
		[self.view addSubview:buttonView[5]];
	
	
	// TODO move lable, write scores on it

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	}
	
	//NSLog(@"7");	
	if(pauseAfterLoop)
	{
		[self pause];
		//NSLog(@"7.5");
		pauseAfterLoop = false;
	}
	//NSLog(@"8");
	//BGView.frame = CGRectMake(0,0,swidth,sheight);
	//BGView.alpha = 1.0;
	//[self.view addSubview:BGView];
	//NSLog(@"9");
	locked =false;
	//NSLog(@"Endind big loop");
	}
	@catch (NSException *exception) {
		//NSLog(@"This aint good in main loop %@: %@",[exception name],[exception reason]);
		//NSString *tempString =[[NSString alloc] initWithCString: "\nLoad failed"];
		//newString = [newString stringByAppendingString:tempString];	
		
	}
	@finally
	{
	}
}
	[self.view addSubview:debugText];
	return;
}
/*- (void)onAnimationComplete:(NSString *)animationID finished:(NSNumber *)finished context:(void *)context {
 
 
 }*/

- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation {
	
	return (interfaceOrientation == UIInterfaceOrientationPortrait);
}

- (void)didReceiveMemoryWarning {
	[super didReceiveMemoryWarning];
	
}

- (void)dealloc {
	[rockImage release];
	for(int i = 0; i <255; i++)
	{
		[rockView[i] dealloc];
		[h20View[i] dealloc];
		[ironView[i] dealloc];
	}
	[super dealloc];
}

-(void)applicationWillTerminate:(NSNotification *)notification
{
	if(app_time < 20)
	{
	//[[NSFileManager defaultManager] removeItemAtPath:[self scoreFilePath]  error:nil];
			[[NSFileManager defaultManager] removeItemAtPath:[self optionsFilePath]  error:nil];
			[[NSFileManager defaultManager] removeItemAtPath:[self dataFilePath]  error:nil];
	}
	else
	{
	[self pause];
	[self SaveScores:level];
	[self SaveOptions];
	[self SaveState];
	}
}




@end
